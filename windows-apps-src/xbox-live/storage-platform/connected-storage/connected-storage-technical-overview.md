---
title: 接続ストレージの技術的な概要
author: aablackm
description: 接続ストレージ内部の動作について詳しく説明します。
ms.assetid: a0bacf59-120a-4ffc-85e1-fbeec5db1308
ms.author: aablackm
ms.date: 02/27/2018
ms.topic: article
ms.prod: windows
ms.technology: uwp
keywords: xbox live, xbox, ゲーム, uwp, windows 10, xbox one, 接続ストレージ
ms.localizationpriority: medium
ms.openlocfilehash: c331e85ef5a0012dd038b9b565106ad076333c07
ms.sourcegitcommit: 63cef0a7805f1594984da4d4ff2f76894f12d942
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 10/05/2018
ms.locfileid: "4392898"
---
# <a name="connected-storage"></a>接続ストレージ

> [!NOTE]
> このドキュメントはもともと、対象パートナーの Xbox One デベロッパー向けに書かれたものです。  Windows 上の UWP の場合、ローカルおよびタイトル ストレージなど、一部の Xbox One 固有の内容は無視することができます。  このドキュメントに記載した概念的な内容や API は依然として関係があります。  ご質問がある場合はマイクロソフトの担当者 (該当する場合) にお問い合わせください。

Xbox One のストレージ モデルとセーブ モデルは、Xbox 360 のモデルとは大きく異なります。Xbox One には、高速アプリケーション切り替え、複数の同時アプリケーション、およびアプリの迅速な一時停止と再開をサポートする、より柔軟なアプリケーション モデルが備わっています。 接続ストレージ API を使用して格納されたデータは、ユーザー用に複数の Xbox One 本体に自動的にローミングされ、オフラインでも使用できます。

このトピックでは、次の内容について説明します。

-   Xbox One で接続ストレージ API を使用してゲームのセーブ データおよびアプリ データを格納する方法。
-   Xbox One のアプリケーション モデルによって提供されるユーザー エクスペリエンスのメリットと適合するようにアプリのセーブ システムを設計するためのベスト プラクティス。
-   接続ストレージ システムが、アプリがセーブ データを保存できる速度を最大化するしくみ。
-   アプリの UI を必要とすることなく、システムが複数の本体からのデータの同期および競合を処理するしくみ。
-   接続ストレージの復元モデル。このモデルは、ネットワーク接続の中断または停電が発生した場合でも、アプリでは、個々のコンテナーに格納されたデータの一貫性が常に確保されるように設計されています。

> [!NOTE]
> ここで使用する "*アプリ*" という用語は、ゲームを含めた、本体上で実行されるあらゆるアプリケーションを指します。

## <a name="overview"></a>概要

Xbox One のアプリケーション モデルでは、ユーザーは複数のアプリケーションを同時に使用できます。これは、本体の電源をオフにする、または別のアプリケーションに切り替える前に、データがセーブされるのを待機するようユーザーに要求することはできないことを意味します。 Xbox One ユーザーは、そのデータを複数の本体に自動的にローミングさせ、どの Xbox One 本体も自身の Xbox One 本体のように使用することができます。 Xbox One プラットフォームでは、アプリケーションでこれらの要件を満たすことができるようにする接続ストレージ API が用意されています。

接続ストレージ システムにより、アプリはデータを 1 つ以上の *BLOB* として*コンテナー*に格納できます。 アプリでデータがセーブされると、データはすぐに排他的パーティションから共有パーティションにコピーされるため、データをディスクに格納し、Xbox Live タイトル ストレージにアップロードするタスクをアプリの有効期間外に処理できるようになります。

アプリが接続ストレージ システムから特定のユーザーのデータを要求すると、システムは自動的にクラウドに更新されたデータがあるかどうかをチェックし、データのダウンロードを待機する必要がある場合はユーザーに通知します。 また、システムは、場合によっては (ユーザーが複数の本体でオフラインでプレイした場合や、別の本体でそのユーザーのセーブ データがアップロードされている場合など)、競合するデータから選択するようユーザーに要求します。

アプリでは、すべてのユーザーに専用の、ただし限られた容量のクラウド ストレージ領域が用意されるため、ユーザーは、別のアプリのセーブ用に領域を確保するために、あるアプリのデータを完全に削除するという難しい選択をせずに済みます。 ただし、セーブをローカルにキャッシュするための Xbox One ハード ドライブ上のストレージ領域の量は限定されているため、システムには、ローカル キャッシュ領域を解放するためのユーザー エクスペリエンスが用意されています。 何がローカルにキャッシュされるかはユーザーが制御します。オフラインでプレイしているときにユーザーが必要なデータにアクセスできなくなることはありません。 接続ストレージ システムでは、アプリ用に、ユーザーに依存しない少量のデータをローカルに格納することもできます。 このマシンごとのデータはローミングされず、クラウドにアップロードされません。

Xbox One の接続ストレージ システムではシステムの電源管理が行われ、保留中のハード ディスクへの書き込みおよびクラウドへのアップロードは自動的に処理されるため、タイトルで "セーブが進行中です。本体の電源を切らないでください" のような UI を表示する必要はありません。

### <a name="the-xbox-one-app-model-and-app-navigation"></a>Xbox One のアプリ モデルとアプリ ナビゲーション

Xbox One では、ユーザーが複数のアプリケーションをすばやく切り替えることができます。 適切に作成されたアプリケーションでは、ユーザーが最後にアクセスしたとき以降アプリがシャットダウンされていた場合でも、ユーザーは前回のアクティビティ時に終了した場所から再開し、関連するコンテキストをすぐに読み込むことができます。

Xbox One 本体では、排他的パーティションでは一度に 1 つのアプリしか実行できません。 アプリを高速に切り替えるユーザー エクスペリエンスを提供するには、ユーザーが別のアプリを実行しようとしたときに、現在実行されている排他的アプリをすぐにシャットダウンする必要があります。 ユーザーが別のアプリに切り替えようとすると、システムはアクティブなアプリに一時停止通知を送信します。 この際、アプリは関連する状態を保存し、その Suspend 関数から戻る必要があります。 システムにより、この操作には最大で 1 秒の時間制限が適用されます。 1 秒以内にアプリが戻らなかった場合、システムはアプリケーションを強制的に終了します。 最新のスマートフォンやタブレットのナビゲーション モデルと同様に、アプリでユーザーがアプリから離れることを阻止することはできません。

ユーザーが本体の電源ボタンを押してシステムがアイドル状態または低電力状態になる場合など、排他的アプリが一時停止される場合もあります。 アプリは、一時停止された場合、システムによってアンロードされることなく再開できます。 これにより、迅速に再開する機能が実現されます。 理解しておくべき重要な点として、一時停止されたアプリは、終了される場合もあれば再開される場合もあります。 終了される場合に備えてアプリでは常に状態を保存する必要があります。

Xbox One のアプリケーション モデルで適切に動作させるには、1 秒間の一時停止時間枠内に関連する状態をセーブできるように、アプリで状態をメモリー バッファーに迅速にシリアル化できるように備えておく必要があります。

ユーザーのゲームプレイに関するセーブ データと、メニュー内の場所のようなアプリの状態に関するデータには違いがある点に注意してください。 アプリが一時停止されたときにゲームプレイをセーブすることに加えて、メインのゲーム エンジン外でユーザーが設定中、またはキャラクターをカスタマイズ中である場合にメニューの状態を保持することを検討する必要があります。

ユーザーは非常に長い時間、ゲームを一時停止したままにする可能性があります。 長い一時停止の後にゲームが再開されたときは、別のエクスペリエンスを提供することを検討してください。 ユーザーが 2 週間プレイしていなかった場合、プレイしていたキャンペーンの銃撃戦の中に戻されることは不快かつ予想外の体験になる可能性があります。一方で、1 時間の休憩はよくあることであり、その場合はすぐにゲームプレイに戻っても問題ありません。

Xbox One のアプリケーション モデルの詳細については、以下のリソースを参照してください。

-   『[リビング ルーム用の最新のアプリケーション切り替え](https://developer.xboxlive.com/en-us/platform/documentlibrary/events/Documents/Xfest%202012/Xfest%202012%20-%20Modern%20Application%20Switching%20for%20the%20Living%20Room.pptx)』(Xfest 2012 のプレゼンテーション)
-   『[シェル エクスペリエンス](https://developer.xboxlive.com/_layouts/xna/download.ashx?file=PROD-D_Experience.pptx&folder=platform/xfest2013)』(Xfest 2013 のプレゼンテーション)
-   『[Process Lifetime Management for Xbox One](https://developer.xboxlive.com/en-us/platform/development/education/Documents/PLM%20for%20Xbox%20One.aspx)』、GDN にあるホワイト ペーパー

> [!NOTE]
> [Xfest 2012](https://developer.xboxlive.com/en-us/platform/documentlibrary/events/Pages/Xfest2012.aspx) および [Xfest 2013](https://developer.xboxlive.com/en-us/platform/documentlibrary/events/Pages/Xfest2013.aspx) の一部のプレゼンテーションには、Xbox One でのオフライン プレイのサポートが発表されたことにより古くなった情報が含まれています。


### <a name="storage-options-on-xbox-one"></a>Xbox One のストレージ オプション

Xbox One ではいくつかのストレージ オプションが用意されており、それぞれに固有の利点と制約があります。 アプリでは、アプリの要件に応じて、オプションを組み合わせて使用することが必要な場合があります。


<a name="connected-storage"></a>接続ストレージ
-----------------

接続ストレージは、複数の本体間でローミングされる必要がある Xbox One のゲームプレイ データや他の関連するアプリの状態データを保存できるように設計されています。 接続ストレージ API は Xbox One に固有であり、そのデータの保存およびアップロードを支援します。 API は Xbox One アプリケーション モデルとの組み合わせで機能します。

接続ストレージ API は、次の機能を提供します。

-   アプリでは一度に最大 16 MB のデータをシステム パーティション内のメモリー バッファーにすばやく保存できます。その後データはシステムによって HDD のローカルにキャッシュされ、クラウドにアップロードされます。
- 対象パートナーおよび ID@Xbox 開発者向け:
  - ユーザー/アプリごとに 256 MB のクラウド ストレージ。
- Xbox Live クリエーターズ プログラム開発者向け:
  - ユーザー/アプリごとに 64 MB のクラウド ストレージ。
-   電源障害に対する堅牢な応答 - アプリでは、データの一部しか保存されないケースに対処する必要がありません
-   アプリが実行されていない場合を含め、データはクラウドに自動的にアップロードされます。
-   データは、Xbox Live に接続されている複数の Xbox One 本体で使用できます。
-   Xbox Live によってデバイス間の同期と競合の管理が処理されるため、アプリケーションが関与する必要はありません。

接続ストレージ API の詳細については、Xbox Live SDK に含まれる xblesdk.chm (Xbox Live Extension SDK API のドキュメント) の該当するセクションを参照してください。


<a name="xbox-live-title-storage"></a>Xbox Live タイトル ストレージ
-----------------------

タイトル ストレージ サービスでは、以下の機能を持つデータ ストレージ用のクロスプラットフォーム REST API が提供されます。

-   ユーザー間、アプリ間、およびさまざまなプラットフォーム間でのデータ共有を提供します
-   バイナリ ファイル、JSON ファイル、および構成ファイルをサポートします
-   対象パートナーおよび ID@Xbox 開発者向け:
    - ユーザー/アプリごとに 256 MB のクラウド ストレージ
    - タイトルごとに 256 MB のグローバル ストレージ
- Xbox Live Creators Program 開発者向け:
  -   ユーザー/アプリごとに 64 MB のクラウド ストレージ
  -   タイトルごとに 256 MB のグローバル ストレージ

サービスを使用するための要件:

-   サービスにアクセスするために Xbox One 本体がオンラインである必要があります。
-   サービスとの相互作用はすべて、アプリの実行中に完了する必要があります。データ転送がバックグラウンドで自動的に完了することはありません。

詳細については、XDK ドキュメントの「*Xbox Live Title Storage*」を参照してください。


<a name="local-temporary-storage"></a>ローカル一時ストレージ
-----------------------

本体上で、アプリは、以下の特性を持つローカル一時ストレージにアクセスできます。

-   パス T:\\ によってアクセス可能な 2 GB の専用ハード ドライブ ストレージ。
-   アプリが実行されていないときにこのストレージのコンテンツを削除可能。

ローカル ストレージの詳細については、XDK ドキュメントの「Local Storage」を参照してください。


<a name="configuring-your-app-for-connected-storage"></a>接続ストレージのためのアプリの構成
------------------------------------------

接続ストレージ API を使用する場合、すべての読み取りおよび書き込み操作は Xbox Live プライマリー サービス構成 ID (SCID) と関連付けられます。SCID はアプリのマニフェスト ファイル AppXManifest.xml で次のように定義されます。

```xml
      <Extensions>
        <mx:Extension Category="xbox.live">
        <mx:XboxLive TitleId="<your title ID>" PrimaryServiceConfigId="<your SCID>"
        RequireXboxLive="<boolean indicating Live requirement>" />
        </mx:Extension>
      </Extensions>
```

アプリのタイトル ID および SCID を取得する方法の詳細については、XDK ドキュメントの「*Xbox Live 開発のためのサンドボックスのセットアップ*」を参照してください。



## <a name="connected-storage-system-concepts"></a>接続ストレージ: システムの概念

ここでは、接続ストレージ システムの構成要素、その関係性、および適切な使用方法について説明します。

### <a name="connected-storage-space"></a>接続ストレージ領域

大まかに言えば、接続ストレージ システム内のすべてのデータは、ユーザーまたはマシン (個々の Xbox One 本体など) のいずれかに関連付けられます。 アプリによって保存される、特定のユーザーまたはマシンのすべてのデータは、接続ストレージ領域に保存されます。

アプリの各ユーザーは接続ストレージ領域を取得しますが、合計で 256 MB の容量に制限されます。 重要な注意点として、このストレージはアプリ専用であり、他のアプリとは共有されません。

アプリには、ローカルの接続ストレージ領域内にマシン用の 64 MB の領域も割り当てられます。 このストレージ領域は、ユーザーとは無関係であり、サインインしているユーザーがいない場合でもアクセスできます。

接続ストレージ領域を取得するには、アプリで *ConnectedStorageSpace.GetForUserAsync メソッド*または *ConnectedStorageSpace.GetForMachineAsync メソッド*を呼び出します。 この処理は、特にユーザーがあるデバイス上でデータを保存しており、別のデバイス上で初めてゲームプレイを再開する場合に、実行時間が長くなる可能性があります。 このプロセスと、接続ストレージ領域の取得をアプリが待機している間に発生する可能性があるエラー状況の詳細については、このホワイト ペーパーで後述されている「*接続ストレージ領域の同期*」を参照してください。

アプリが **ConnectedStorageSpace** オブジェクトを取得した後、そのオブジェクトまたはそのオブジェクトから派生する他のオブジェクトを使用する、*Windows.Storage 名前空間*配下のすべてのメソッドの呼び出しは、Web サービスからの応答に依存せずに完了できます。 ただし、Xbox One HDD へのアクセスはアクティブなアプリに限定されていないため、これらのメソッドで最大限のパフォーマンスが実現されることは保証されません。


### <a name="connected-storage-containers-and-blobs"></a>接続ストレージ: コンテナーと BLOB

*接続ストレージ コンテナー* (または単に*コンテナー*) はストレージの基本単位です。 次の図に示されているように、それぞれの接続ストレージ領域には多数のコンテナーを含めることができます。

**図 1:   接続ストレージ領域 (タイトル/マシンごとまたはタイトル/ユーザーごと)**

![](../../images/connected_storage/connected_storage_space_containers.png)
データは、*BLOB* と呼ばれる 1 つ以上のバッファーとしてコンテナー内に保存されます。 次の図は、ディスク上のコンテナーの内部システム表現を示しています。 コンテナーごとに、コンテナー内の各 BLOB に対応するデータ ファイルへの参照を含むコンテナー ファイルがあります。

**図 2.  コンテナーの図**

![](../../images/connected_storage/container_storage_blobs.png)

コンテナーにデータを格納するには、名前および BLOB (Buffer オブジェクト) のマップを指定して *ConnectedStorageContainer.SubmitUpdatesAsync メソッド*を呼び出します。 **SubmitUpdatesAsync** 呼び出しで記述されたすべての変更はアトミックに適用されます。つまり、要求どおりすべての BLOB が更新されるか、操作全体が中止されてコンテナーが呼び出しの前の状態のままとなるかのどちらかです。

**SubmitUpdatesAsync** を使用する個々の保存処理では、一度に 16 MB のデータに制限されます。


### <a name="submitupdatesasync-behavior"></a>SubmitUpdatesAsync の動作

**SubmitUpdatesAsync** が呼び出されると、呼び出しで指定されたバッファーが、アプリケーション パーティションからシステム パーティションの専用のメモリー領域にすぐにコピーされます。 メモリーがシステム パーティションに正常にコピーされると、**SubmitUpdatesAsync** 呼び出しで指定された完了ハンドラーがアプリ内で呼び出され、データ用にローカルで割り当てたメモリーを解放しても安全であることがアプリに伝えられます。

その後、システムが BLOB を本体のハード ドライブに保存し、そのコンテナーでの操作全体をコミットする最終的なコンテナーの更新を実行して操作を完了します。

**SubmitUpdatesAsync** データを受け取るための共有パーティション内のメモリーには 16MB の上限があります。 専用の 16 MB バッファー内に空きメモリーが十分にないために、システムが **SubmitUpdatesAsync** の呼び出しを即座に処理できない場合、呼び出しは処理のキューに入れられます。 システムによって 16 MB のバッファーからハード ドライブにデータが継続的に転送され、16 MB のバッファー内の領域が使用できるようになると、キューに入れられた更新が要求された順序で処理されます。

**図 3:   SubmitUpdatesAsync の動作**

![](../../images/connected_storage/submitupdatesasync_behavior.png)
クラウドへのアップロードも同様の方法で行われます。個々の BLOB がサービスにアップロードされ、更新操作は、他のすべてのアップロードされた BLOB を参照するコンテナー ファイルの最終的な更新によってコミットされます。 クラウドへのアップロードでは、このように 1 回の最終的な更新に統合することで、**SubmitUpdatesAsync** 呼び出しで参照されているすべてのデータが完全にコミットされるか、コンテナーが変更されないままになるかのどちらかになります。 このようにすることで、アップロード処理中にシステムがオフラインになったり、電源が切断されたりした場合でも、ユーザーは別の Xbox One 本体にアクセスして、クラウドからデータをダウンロードし、すべてのコンテナーが一貫した状態でプレイを続行できます。

> [!IMPORTANT]
> コンテナーをまたいだデータの依存性は安全ではありません。  個々の *SubmitUpdatesAsync* 呼び出しの結果は、完全に適用されるか、まったく適用されないかのどちらかになることが保証されます。

**SubmitUpdatesAsync** 呼び出しでは、コンテナーの有効な状態を保つために、その後の **SubmitUpdatesAsync** 呼び出しが正常に完了することを想定しないでください。 つまり、アプリは、必要なすべてのデータをコンテナーに保存するために複数の **SubmitUpdatesAsync** 呼び出しに依存することはできません。 各 **SubmitUpdatesAsync** 呼び出しで、指定されたコンテナーの内容を有効な状態にし、アプリケーションが後で読み取ることができるようにする必要があります。

この問題を説明するために、Bob というキャラクターが所有するゴールドと食料の量をコンテナーで追跡するシナリオについて考えてみましょう。 タイトルでは、*food* と *gold* という 2 つの BLOB を格納できます。 Bob はインベントリーに 100 ゴールドあり、食料はない状態でスタートします。

**図 4:   サンプル シナリオ: Bob は 100 ゴールドがある状態でスタートする。**

![](../../images/connected_storage/submitupdatesasync_example_scenario1.png)

ここで、Bob が 50 ゴールドを消費します。 タイトルは、金の BLOB の値を 50 に更新する **SubmitUpdatesAsync** 呼び出しを準備します。

システムは、更新された BLOB とコンテナー更新に関する情報を更新バッファーにキャプチャーします。 システムは新しい BLOB の値をハード ドライブにコピーします。

**図 5:   システムが更新された情報をキャプチャーし、値をハード ドライブにコピーする。**

![](../../images/connected_storage/submitupdatesasync_example_scenario2.png)

最後に、システムは、新しい BLOB を参照するように HDD 上のコンテナー ファイルを更新します。 最終的に、システムは、参照されていない BLOB をガベージ コレクション操作で削除します。

**図 6:   システムが HDD 上のコンテナー ファイルを更新し、参照されていない BLOB を削除する。**

![](../../images/connected_storage/submitupdatesasync_example_scenario3.png)

1 つの **SubmitUpdatesAsync** 呼び出しで使用する BLOB が増えれば増えるほど、データを確実に格納するために必要なアトミックなファイル システム処理の完了に要する時間は長くなります。 前の例でのデータ ストレージの粒度は非常に小さなものですが、これは、1 つのコンテナー内の複数の BLOB をアトミック更新する動作を明確に示すことを意図しています。


### <a name="updating-multiple-blobs--the-wrong-way"></a>複数の BLOB の更新 – 間違ったやり方

Bob が食料を購入するシナリオを考えます。 わかりやすくするために、1 単位のゴールドで 1 単位の食料を買うことができ、Bob が 25 単位の食料を買うことにします。 アプリでは、25 単位の食料を追加する **SubmitUpdatesAsync** 呼び出しと、25 単位のゴールドを Bob\_Inventory コンテナーから差し引く別の呼び出しを発行できます。 ただし、両方の **SubmitUpdatesAsync** 呼び出しの完了ハンドラーが呼び出された場合でも、ハード ドライブへのデータの書き込みを停止させる可能性がある停電や、クラウドへの不完全な同期などが原因で、誤った結果となる場合があります。 以下の図は、システムによって実行される手順と、いずれかの手順で停電が発生した場合の結果について説明しています。

両方の **SubmitUpdatesAsync** 呼び出しからのデータはシステムの更新バッファーに既に含まれており、両方の呼び出しのタイトルの完了ハンドラーが呼び出されたものと仮定します。

まず、システムが食料の BLOB の新しい値のデータをディスクに書き込みます。

**図 7:   システムが食料の BLOB の値をディスクに書き込む。**

![](../../images/connected_storage/update_method_wrong_way_1.png)
次に、システムは、新しく書き込まれた値を参照するようにコンテナーを更新します。 次の図に示されているように、この手順の実行後、次の手順の前に電源が失われた場合、Bob は、対応するゴールドをインベントリーから差し引かれずに 25 単位の食料を得るという得な取引をすることになります。

**図 8:   新しく書き込まれた値を参照するようにシステムがコンテナーを更新する。**

![](../../images/connected_storage/update_method_wrong_way_2.png)

次に、システムはゴールドの BLOB の新しい値のデータをディスクに書き込みます。 Bob\_Inventory コンテナーによって参照されるゴールドの値がまだ更新されていないため、Bob は本来よりも 25 単位多いゴールドを持っていますが、目的の結果に一歩近づきました。

**図 9:   システムがゴールドの BLOB の新しい値のデータをディスクに書き込む。**

![](../../images/connected_storage/update_method_wrong_way_3.png)

最後に、システムは新しく書き込まれたゴールドの BLOB を参照するようにコンテナー ファイルを更新し、これで意図した結果が実現されます。

**図 10:   新しく書き込まれたゴールドの BLOB を参照するようにシステムがコンテナー ファイルを更新する。**

![](../../images/connected_storage/update_method_wrong_way_4.png)

### <a name="updating-multiple-blobs--the-right-way"></a>複数の BLOB の更新 – 正しいやり方

停電によって誤った中間状態が発生する可能性がないように、Bob のインベントリーのゴールドと食料の量がアトミックに更新されるようにする適切な方法は、1 回の **SubmitUpdatesAsync** 呼び出しで両方の BLOB を更新することです。 この場合、システムでは次のような手順が実行されます。

まず、システムが食料の BLOB の新しい値のデータをディスクに書き込みます。

**図 11:   システムが食料の BLOB の新しい値のデータを書き込む。**

![](../../images/connected_storage/update_method_right_way_1.png)
次に、システムはゴールドの BLOB の新しい値のデータをディスクに書き込みます。

**図 12.  システムがゴールドの BLOB の新しい値のデータを書き込む。**

![](../../images/connected_storage/update_method_right_way_2.png)
最後に、システムが、両方の新しい BLOB を参照するようにコンテナー ファイルを更新します。

**図 13.  両方の新しい BLOB を参照するようにシステムがコンテナー ファイルを更新する。**

![](../../images/connected_storage/update_method_right_way_3.png)
この例は非常に単純ですが、目的の更新をすべて含む 1 回の **SubmitUpdatesAsync** 呼び出しを発行することで、コンテナー内のデータに対してアトミックに適用されるべきすべての変更を実行することの重要性を示しています。 ゴールドで食料を購入するケースをこのように処理することで、アプリでは、誤って一方の値のみが更新され、本来よりも多いゴールドがキャラクターに残る可能性がある競合条件を回避します。

### <a name="performance-characteristics-and-considerations"></a>パフォーマンス特性と考慮事項

共有パーティションの 16 MB の更新バッファーでは、限られた数の更新処理を非常に迅速に実行できます。 システムがデータをディスクに保存できる速度は、バッファー内のデータ量と BLOB の数の両方によって異なります。 各 BLOB は復元性が確保されるようにディスクに書き込まれるため、バッファー内の BLOB 数が多くなればなるほど、ディスクへの保存にかかる時間は長くなります。

図 13 は、システムで他のハード ドライブ処理がない場合に、2 秒ごとに **SubmitUpdatesAsync** 操作で 2 回の 512 K の BLOB 更新と 1 回の 1,024 K の BLOB 更新を処理した場合の時間の例を示しています。 システムは安定状態で稼働でき、各更新を 14 ～ 18 ミリ秒以内に処理します。

**図 14.  他のハード ドライブ アクティビティがない場合に、2 秒ごとに SubmitUpdatesAsync 操作で 2 回の 512 K の BLOB 更新と 1 回の 1,024 K の BLOB 更新を処理した場合の時間。**

![](../../images/connected_storage/submitupdatesasync_proc_time_mixed_size_fixed_interval.png)
図 14 は、さまざまな時間間隔で 3 つの 1,024 K の BLOB を処理した場合の時間を示しています。

システムは、3 秒間隔では 87 ミリ秒の安定状態でこれらの更新を処理できます。 頻度を 2 秒間隔に上げても、システムは 87 ミリ秒以内の安定状態で更新を処理できます。

更新間隔を 1 秒に縮めると、安定状態の動作が変わります。 システムは、60 個の更新までは更新あたり 87 ミリ秒で処理できますが、それ以降は各更新にかかる時間が非常に長くなり、大幅な変動を伴って、更新あたりの処理時間が 500 ミリ秒の安定状態に達します。 これは、データがディスクにフラッシュされるよりも速く 16 MB のメモリー バッファーがいっぱいになり、更新処理で、前の更新が書き込まれるのを待機しなければならないことが原因です。

0.5 秒間隔で 1 回の更新を実行すると、影響は劇的に大きくなります。 この間隔では、システムは、非常に大きな変動を伴いながら、各更新の処理に 1 秒を超える時間がかかる安定状態に達するまで、更新あたり 87 ミリ秒で 7 回の更新しか処理できません。

**図 15:   さまざまな時間間隔で 3 つの 1,024 K の BLOB を処理した場合の時間。**

![](../../images/connected_storage/submitupdatesasync_proc_time_fixed_size_various_intervals.png)
これらは説明のための例にすぎません。 通常、アプリはこのような頻度でデータを保存するべきではありませんが、ディスク I/O のない環境で動作することも通常はありません。

以上の例に基づいてシステムの特性を理解すること、すなわち、さまざまな稼働条件下でアプリを計測し、アプリの一時停止ハンドラーの実行中に 1 秒未満で保存操作を完了できるようにすることが重要です。


## <a name="synchronizing-a-connected-storage-space"></a>接続ストレージ領域の同期

-   接続のチェック
-   ロックの取得
-   コンテナーの一覧表示、比較、および結合ロジック
-   コンテナーのダウンロード

アプリから接続ストレージ領域へのアクセスを要求されると、システムは同期プロセスを実行し、Xbox One 本体間でユーザーのセーブ データが一貫した状態で維持されるようにし、そのデータをオフライン プレイで使用できるようにします。 同期は、その所要時間が変動する可能性があり、ユーザーの判断を必要とする場合があるため、そのプロセスのさまざまな段階でシステムからユーザーに UI が表示されることがあります。

同期 UI がアクティブな場合でも、ユーザーは Xbox ボタンを押していつでもアプリを離れることができます。 システムは UI を非表示にし、ユーザーの操作なしで可能な範囲で同期は続行されます。 ユーザーがアプリに戻ると、同期が完了していない限り、UI が再度表示されます。 UI が非表示のときに、ユーザーの選択をシステムが勝手に推測することはありません。

ユーザーがホーム画面にいるときはシステムは同期 UI を表示せず、アプリのレンダリングは大きなアプリ タイルに表示され続けるため、**GetForUserAsync** 呼び出しの完了を待っている間、アプリでは状況に応じて適切なビジュアルをレンダリングすることが重要です。 レンダリングを続行することで、アプリがまだインタラクティブであり、データの読み込みを待機していることがユーザーに示されます。

次の図は、アプリから接続ストレージ領域を要求されたときの、システムのシーケンスを大まかに示しています。 シーケンス全体に数秒以上かかる場合は、システムによって同期 UI が表示されます。

**図 16:   アプリから接続ストレージ領域を要求されたときのシステムのシーケンス。**

![](../../images/connected_storage/app_requests_connected_storage_space.png)
システムは、以下の段階を経て **GetForUserAsync** 要求を処理します。

-   接続のチェック
-   ロックの取得
-   コンテナーの一覧表示、比較、および結合ロジック
-   コンテナーのダウンロード

### <a name="connectivity-check"></a>接続のチェック

**GetForUserAsync** 要求の処理を開始するために、システムは接続をチェックします。 本体がオフラインの場合、同期プロセス全体が省略され、現在のセッションの間、指定されたユーザーの接続ストレージ領域はオフラインとマークされます。 次にアプリが同じユーザーの接続ストレージ領域にアクセスし、システムがタイトル ストレージ サービスに到達できたときに、変更されたデータがクラウド ストレージと照合されます。 この場合、UI は表示されません。

接続ストレージのコンテキスト以外でのオフライン処理の詳細については、『*Xbox One タイトルのサービス中断からの復帰性*』を参照してください。

### <a name="lock-acquisition"></a>ロックの取得

接続の確認後、システムは、アプリおよび現在のユーザーに関連付けられているクラウド ストレージ領域への排他的アクセスを取得しようとします。 これは、タイトル ストレージの接続ストレージ領域にロック ファイルを配置することで実行されます。 本体がオンラインで、サービスに到達可能であり、短時間でロックを取得できる場合、UI は表示されず、同期プロセスが続行されます。

システムが特定の接続ストレージ領域のロックを取得し、接続ストレージ領域のインスタンスをアプリに返した場合、Web 要求の成功時には、その接続ストレージ領域内のデータに対して実行されるアプリの API 呼び出しはいずれもブロックされません。 ロックによって十分な保護が提供されるため、アプリが接続ストレージ領域を取得した後にユーザーがシステムからネットワーク ケーブルを取り外しても、API 呼び出しはローカルで使用可能なデータに基づいて動作します。

ロックの取得手順中に発生する可能性があるエラー シナリオがいくつかあります。

 **同期 UI** 本体はオンラインであるが、短時間でサービスからロックが取得されなかった場合、"同期中"の UI が表示されます。

 **ロックの解除** ユーザーが、アプリを現在の本体で最後にプレイしてから別の本体でプレイした場合は、別の本体がストレージ領域への排他的アクセスを所有していて、データのアップロード中である場合があります。 また、別の本体でデータのアップロードが開始されたが、終了する前にその接続または電源が失われた可能性もあります。

どちらのケースも*ロックの競合*と呼ばれ、いずれのケースでも、別の本体がデータのアップロード中であることを説明する UI がシステムによって表示されます。 ユーザーは、このプロセスが完了するのを待機するか、クラウド内の現時点で利用可能なデータを使用することができます。 ユーザーがクラウド データを使用することを選択した場合、システムはそのシステム用のロックを取得して (ロックを解除して)、ユーザーおよびアプリのクラウド ストレージへの排他的アクセスを取得します。 他の本体からのアップロードはキャンセルされ、同期プロセスが続行されます。

### <a name="container-listing-comparison-and-merger-logic"></a>コンテナーの一覧表示、比較、および結合ロジック

ロックの取得後、システムは指定されたアプリおよびユーザーのクラウド内のすべてのコンテナーの一覧表示を要求します。 次に、ローカル ハード ドライブの内容とクラウド内のデータを比較し、比較の結果に応じて処理を進めます。

 **ローカル データがクラウドと一致する場合** 他の本体からの変更がなく、クラウドとローカル ハード ドライブ内のデータが同じである場合、同期は完了しており、この時点で **GetForUserAsync** 呼び出しの完了ハンドラーが呼び出され、アプリは読み込みとセーブを開始することができます。

 **ローカル データがない場合** クラウドにはデータがあるが、ローカルの本体にはない場合、データがクラウドからローカルにダウンロードされます。 これが発生する可能性があるのは、ユーザーが友人の家で初めてプレイする場合などです。

 **同じコンテナーがローカルとクラウドで変更された場合** ユーザーが、別の本体でプレイしてクラウド内のコンテナーを変更し、現在の本体をオフラインで使用して同じコンテナーを変更した場合、データは自動的に結合されません。 ユーザーは保持するデータを選択するよう求められます。 競合が発生した場合、ユーザーは置き換えポリシーを選択できます。ローカル データまたはクラウド データのどちらかが常に保持されるようにするか、**キャンセル**を選択して決断を先送りできます。 ユーザーが置き換えポリシーとしてクラウド データまたはローカル データのどちらかを選択した場合、同じ名前であるが内容が異なるコンテナーは、そのポリシーに従って解決されます。

ユーザーが**キャンセル**を選択した場合、ユーザーがオフラインでプレイしていたかのように、タイトルは未解決状態のセーブ システムにアクセスできるようになります。 この場合、次に、本体がオンラインである場合にアプリが接続ストレージ領域へのアクセスを要求したときに、競合解決 UI が再度表示されます。

### <a name="container-download"></a>コンテナーのダウンロード

競合が解決されると、システムでは、クラウドからダウンロードする必要があるコンテナーを識別するために必要なすべての情報が整います。 必要なすべてのコンテナーがダウンロードされ、この時点で *ConnectedStorageSpace.GetForUserAsync Method* 呼び出しの完了ハンドラーが呼び出され、アプリは読み込みとセーブを開始できます。

この手順中、いくつかのエラーが発生する可能性があります。

**ローカル ストレージの不足**  
必要なコンテナーのためのローカル ハード ドライブ領域が不足している場合、ローカルに保存されているデータを削除してディスク領域を空けるよう求める UI がユーザーに表示されます。 クラウドにバックアップされていない重要なデータをユーザーが完全に削除してしまわないように、UI では、単なるローカル キャッシュであるデータと現在の本体のみに保持されているデータが明確に示されます。

ユーザーに UI が表示されたときの処理は次のとおりです。

-   ユーザーが十分な領域を解放した場合、同期が続行され、完了します。
-   ユーザーが十分な領域を解放せずに UI をキャンセルした場合、**GetForUserAsync** 呼び出しの完了ハンドラーは **OutOfLocalStorage** を返します (「*ConnectedStorageErrorStatus Enumeration*」を参照)。 アプリでは、データをセーブできない状態でプレイしようとしていることをユーザーに確認する必要があります。 ユーザーが同意した場合、アプリではそのユーザーのデータをセーブせずに処理を進める必要があります。 ユーザーがプレイ中にデータをセーブすることを希望した場合、アプリでは再び **GetForUserAsync** を呼び出して、領域を解放するための UI を表示させる必要があります。

**ユーザーが同期をキャンセルする**  
ユーザーが同期の完了を待たずにキャンセルを選択した場合、すべてのセーブ データが使用できるようにはならないことがユーザーに通知されます。 この時点で **GetForUserAsync** 呼び出しの完了ハンドラーが呼び出され、アプリは読み込みとセーブを開始できます。

**ネットワーク タイムアウト**  
ネットワーク接続またはサービスの可用性の問題が原因でデータのダウンロードがタイムアウトになった場合、ユーザーには、同期を再試行するオプションが提供されます。 再試行しないことを選択した場合、すべてのセーブ データが使用できるようにはならないことがユーザーに通知されます。 この時点で **GetForUserAsync** 呼び出しの完了ハンドラーが呼び出され、アプリは読み込みとセーブを開始できます。

## <a name="development-tools"></a>開発ツール

XbStorage と Fiddler という 2 つのツールが、接続ストレージを使用するアプリの開発に役立ちます。

### <a name="managing-connected-storage-with-xbstorage"></a>XbStorage を使用した接続ストレージの管理

XbStorage は、Xbox One 開発キット上のローカルの接続ストレージ データを開発用 PC から管理するための開発ツールです。

このツールでは、ローカルの接続ストレージ領域をハード ドライブから消去したり、XML ファイルを使用して個々のユーザーまたはマシンの接続ストレージ領域をインポートおよびエクスポートしたりできます。

ローカルの接続ストレージ領域で操作が実行されると、システムは、その処理がアプリ自体によって実行された場合と同様に動作します。 接続ストレージ領域からローカル ファイルにデータをコピーすると、コピーの前にクラウドとの同期が行われます。

同様に、開発用 PC 上の XML ファイルから Xbox One 開発キット上の接続ストレージ コンテナーにデータをコピーすると、そのデータをクラウドにアップロードする処理が本体によって開始されます。 1 つの例外があります。開発キットがロックを取得できない場合、つまり、本体上のコンテナーとクラウド上のコンテナーの間で競合がある場合です。 そのような場合、本体は、(保持するコンテナーのバージョンを選択するなどして) ユーザーが競合を解決しないと決定した場合と同様に動作し、次にタイトルが起動されるまで、オフラインでプレイする場合と同様に動作します。

XbStorage の reset コマンドは、すべての SCID およびユーザーのセーブ データのローカル ストレージを消去しますが、クラウドに格納されているデータは変更しません。 これは、ユーザーが別の本体にローミングして、タイトルのプレイ時にクラウドからデータをダウンロードする状態に本体を設定する際に役立ちます。

XbStorage の詳細については、XDK ドキュメントの「*接続ストレージの管理 (xbstorage.exe)*」を参照してください。

### <a name="monitoring-connected-storage-network-activity-using-fiddler"></a>Fiddler を使用した接続ストレージのネットワーク アクティビティの監視

クラウド ストレージの処理の実行時に、本体がサービスとやり取りしているかどうかを確認できると便利な場合があります。 Fiddler を使用すると、本体でサービスの呼び出しが正常に行われているかどうか、または本体で承認エラーが発生しているかどうかの確認に役立ちます。 Xbox One での Fiddler の設定方法については、この XDK ドキュメントの「*Xbox One で Fiddler を使用する方法*」を参照してください。

## <a name="resources"></a>リソース

これまでに示したリソースに加えて、以下のものがアプリまたはタイトルの開発に役立つ場合があります。

-   XDK ドキュメントの「接続ストレージの概要」
-   Game Developer Network (GDN) の「Samples」から入手可能な [Process Lifetime Management](https://developer.xboxlive.com/_layouts/xna/download.ashx?file=ProcessLifetimeManagement_08_2013_qfe5.zip&folder=platform/aug2013xdk_qfe5/samples) サンプル
-   GDN の「ホワイト ペーパー」で提供されているホワイト ペーパー『[Xbox One のプロセス ライフタイム管理 (PLM)](https://developer.xboxlive.com/en-us/platform/development/education/Documents/PLM%20for%20Xbox%20One.aspx)』
