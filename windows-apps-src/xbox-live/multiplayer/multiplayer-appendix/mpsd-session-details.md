---
title: マルチプレイヤー セッションの詳細
author: KevinAsgari
description: Xbox Live マルチプレイヤー セッションの詳細について説明します。
ms.assetid: 5aeae339-4a97-45f4-b0e7-e669c994f249
ms.author: kevinasg
ms.date: 04/04/2017
ms.topic: article
keywords: Xbox Live, Xbox, ゲーム, UWP, Windows 10, Xbox One, マルチプレイヤー 2015, セッション テンプレート, MPSD
ms.localizationpriority: medium
ms.openlocfilehash: ad551d07d94f90d89f8abda0b188ea281b4930c2
ms.sourcegitcommit: 144f5f127fc4fbd852f2f6780ef26054192d68fc
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 11/03/2018
ms.locfileid: "5986534"
---
# <a name="mpsd-session-details"></a>MPSD セッションの詳細

この記事は、次のセクションで構成されています。
* セッションの概要
* セッション機能
* セッション サイズ
* セッションのユーザーの状態
* 可視性と参加可能性
* セッション タイムアウト
* 1 台の本体にサインインした複数のユーザー
* プロセス ライフサイクル管理
* 非アクティブなセッションのクリーンアップ
* セッション アービター

## <a name="session-overview"></a>セッションの概要

マルチプレイヤー セッション ディレクトリ (MPSD) セッションはセッションの名前を持つし、は、セッションの既定の設定を提供する JSON ドキュメントは、セッション テンプレートのインスタンスとして識別されます。 テンプレートは、サービス構成 id (SCID) でサービス構成の一部は GUID です。 このテンプレートにある [ [Xbox デベロッパー ポータル (XDP)](https://xdp.xboxlive.com)と、 [Windows デベロッパー センター](https://partner.microsoft.com/dashboard/windows/overview)サービス構成は、開発者向けリソースの取り込み、管理、およびセキュリティ ポリシーを使用します。 セッションを MPSD を介してアクセスすると、XDP または Windows デベロッパー センターを通じてデベロッパーが設定したアクセス ポリシーに従って、サービス構成に対してプリンシパルの承認が実行されます。 サービス構成へのアクセスが承認された後にセッションが読み込まれると、セッションのメンバーシップ検証などのセカンダリー アクセス チェックがセッション レベルで実行されます。

ここでは、テンプレートでコントラクト バージョン 107 を使用していると仮定します。このコントラクト バージョンは、Xbox One の現在の MPSD で使用されているバージョンです。 コントラクト バージョン 105 (104 と同じ) に基づいてテンプレートを定義した場合は、バージョン 107 をサポートするためにこれらを変更してください。 手順については、「[マルチプレイヤー 2015 での移行における一般的な問題](common-issues-when-adapting-multiplayer.md)」を参照してください。

| 重要                                                                                                                                                                                                                                                      |
|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| テンプレートを使用して設定された機能は、MPSD への書き込みによって変更できません。 値を変更するには、必要な変更を行った新しいテンプレートを作成し、送信する必要があります。 テンプレートで設定されない項目はすべて、MPSD への書き込みによって変更できます。 |

### <a name="session-reference"></a>セッション参照

各 MPSD セッションは、セッション参照によって一意に参照され、**MultiplayerSessionReference クラス**によってマルチプレイヤー WinRT API で表されます。 セッション参照には以下の文字列値が含まれています。

-   サービス構成 ID (SCID)
-   セッション テンプレート名
-   セッション名

セッション参照は、次に示すように、セッションを識別するための URI にマップします。 次のマッピング例では、"authority" は sessiondirectory.xboxlive.com です。

```HTTP
https://{authority}/serviceconfigs/{service-config-id}/sessiontemplates/{session-template-name}/sessions/{session-name}
```

### <a name="elements-of-a-session"></a>セッションの要素

各セッションには、セッションの要素ごとに異なる変更可能性およびセキュリティ規則を適用する要素のグループと、読み取り専用のハウスキーピング情報 (メタデータ) が含まれています。 ここでは、セッションを構成するために JSON ファイルに含まれるセッション要素のグループと、選択したテンプレートの JSON ファイルに含まれるセッション要素のグループについて説明します。

| 注意                                                                                                                                                   |
|---------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| HTTP/REST 実装に WinRT ラッパーを使用している場合は、セッションおよびテンプレートで、WinRT の機能を正確に反映する JSON オブジェクトを定義する必要があります。 |

各要素グループ内には、次の 2 つの内部オブジェクトがあります。

-   システム オブジェクト - これらのオブジェクトには、MPSD によって適用および解釈される固定のスキーマがあります。 システム オブジェクトは検証およびマージされます。 MPSD は、システム オブジェクトの意味を定義し、把握しているので、それらに従って動作することができます。 各システム オブジェクトの完全な定義については、「**MultiplayerSession クラス**」のリファレンスおよび「**セッション ディレクトリ URI**」のリファレンスを参照してください。
-   カスタム オブジェクト - これらのオブジェクトはオプションであり、スキーマはありません。 マルチプレイヤー ゲームに関するメタデータを格納するために使用されます。 MPSD はこのデータを解釈できないので、それらに従って動作しません。 ゲーム データまたは保存される情報はタイトル管理ストレージ (TMS) に格納される必要があります。 TMS の詳細については、「**Xbox Live タイトル ストレージ**」を参照してください。

カスタム JSON オブジェクトの例を次に示します。
```JSON
    "custom": {
      "myField1": true,
      "myField2": "string",
      "myField3": 5.5,
      "myField4": { "myObject": null },
      "myField5": [ "my", "array" ]
    }
```

#### <a name="session-constants"></a>セッション定数

セッション定数は、作成時にのみ、作成者またはセッション テンプレートによって設定されます。 /constants/system オブジェクトは、MPSD を介して認識され、マルチプレイヤー システムの定数を定義するために使用されます。 このオブジェクトに関連付けられている WinRT ラッパーは、**MultiplayerSessionConstants クラス**によって表されます。

/constants/system オブジェクトは、capabilities オブジェクト、metrics オブジェクト、managedInitialization (テンプレート コントラクト バージョン 104/105) または memberInitialization (コントラクト バージョン 107) オブジェクト、peerToPeerRequirements オブジェクト、peerToHostRequirements オブジェクト、measurementsServerAddresses オブジェクトなど、多数の項目を定義できます。


#### <a name="session-properties"></a>セッションのプロパティ

/properties/system オブジェクトを使用して MPSD 用のセッションのプロパティを定義します。 このオブジェクトに関連付けられている WinRT ラッパーは、**MultiplayerSessionProperties クラス**です。 セッションのプロパティは、いつでもセッション メンバーによる書き込みが可能です。 JSON 形式によるセッションのプロパティの例には、joinRestriction、initializationSucceeded、マッチメイキング オブジェクトなどがあります。 この要素グループの使用例については、「[ターゲット セッションの初期化と QoS](smartmatch-matchmaking.md)」を参照してください。


#### <a name="member-constants"></a>メンバー定数

各セッション メンバーの参加時にメンバー定数を設定します。 JSON オブジェクトは /members/{index}/constants/system です。 セッション メンバーを表す WinRT のラッパー クラスは、**MultiplayerSessionMember クラス**です。


## <a name="member-properties"></a>メンバーのプロパティ

メンバーのプロパティはセッション メンバーのみが書き込み可能です。 /members/{index}/properties/system オブジェクトで設定され、**MultiplayerSessionMember クラス**の要素が反映されます。 以下に例を示します。

```
    {
      // These flags control the member status and "activeTitle", and are mutually exclusive (it's an error to set both to true).
      // For each, false is the same as not present. The default status is "inactive", i.e. neither present.
      "ready": true,
      "active": false,

      // Base-64 blob, or not present. Empty string is the same as not present.
      "secureDeviceAddress": "ryY=",

      // During member initialization, if any members in the list fail, this member will also fail.
      // Can't be set on large sessions.
      "initializationGroup": [ 5 ],

      // List of the groups I'm in and the encounters I just had.
      // An encounter is a brief interaction with a group. When an encounter is reported, it counts as retroactively joining the group 30 seconds ago and just now leaving.
      // Group names use the session name validation rules (e.g. case-insensitive).
      // On large sessions, groups are used to report who played with who (rather than just session membership). Members
      // that are active in at least one group together at the same time are counted as playing together.
      // Empty lists are the same as no value specified.
      // The set of encounters is a point-in-time property, so it's immediately consumed and will never appear on a response.
      "groups": [ "team-buzz", "posse.99" ],
      "encounters": [ "CoffeeShop-757093D8-E41F-49D0-BB13-17A49B20C6B9" ],

      // Optional list of role preferences the player has specified for role-based game modes.
      // All role names have to match across all members in the session. Role weights are
      // defined from 0-100.
      "RolePreference": { "medic": 75, "sniper": 25, "assault": 50, "support": 100 },

      // QoS measurements by lower-case device token.
      // Like all fields, "measurements" must be updated as a whole. It should be set once when measurement is complete, not incrementally.
      // Metrics can be omitted if they weren't successfully measured, i.e. the peer is unreachable.
      // If a "measurements" object is set, it can't contain an entry for the member's own address.
      "measurements": {
        "e69c43a8": {
          "bandwidthDown": 19342,  // Kilobits per second
          "bandwidthUp": 944,  // Kilobits per second
          "custom": { }
        }

      // QoS measurements by game-server connection string. Like all fields, "serverMeasurements" must be updated as a whole, so it should be set once when measurement is complete.
      // If empty, it means that none of the measurements completed within the "serverMeasurementTimeout".
      "serverMeasurements": {
        "server farm a": {
          "latency": 233  // Milliseconds
        }
      },

      // Subscriptions for shoulder taps on session changes. The "profile" indicates which session changes to tap as well as other properties of the registration like the min time between taps.
      // The subscription is named with a title-generated GUID that is also sent back with the tap as a context ID.
      // Subscriptions can be added and removed individually, without affecting other subscriptions in the "subscriptions" object.
      // To remove a subscription, set its context ID to null.
      // (Like the "ready" and "active" flags, the "subscriptions" data is copied out and maintained internally, so the normal replace-all rule on system fields doesn't apply to "subscriptions".)
      // Can't be set on large sessions.
      "subscriptions": {
        "961dc162-3a8c-4982-b58b-0347ed086bc9": {
          "profile": "party",  // Or "matchmaking", "initialization", "roster", "queuehost", or "queue"
          "onBehalfOfTitleId": "3948320593",  // Optional decimal title ID of the registered channel.  If not set the title ID is taken from the token.
        },
        "709fef70-4638-4b94-905b-24cb02706eb5": null
      }
    }
```

#### <a name="server-elements"></a>サーバー要素

サーバーは、セッションに参加した、または招待された、ユーザーではないメンバーです。 関連付けられている JSON オブジェクトは、/servers/{server-name}/constants/system と /servers/{server-name}/properties/system です。 これらのオブジェクトはサーバーのみが書き込み可能です。

| 注意                                                         |
|---------------------------------------------------------------------------|
| /servers/{server-name}/constants/system オブジェクトは現在使用されていません。 |


### <a name="session-configuration"></a>セッションの構成

セッションの構成を制御するには、次の 2 つの方法があります。

-   XDP または Windows デベロッパー センターを通じて取り込まれたセッション テンプレートを使用します。
-   Multiplayer および Matchmaking WinRT API または REST API への呼び出しを使用します。 この場合もテンプレートを使用する必要がありますが、構成する値がテンプレートに含まれている必要はありません。 タイトルは、テンプレートで既に設定されている定数をオーバーライドできないことに注意してください。

セッション自体を定義するために別の JSON ドキュメントが提供されます。 さらに、デベロッパーは、特定のタイトルに必要な WinRT ラッパー機能を実装する必要があります。 JSON ドキュメントとすべての WinRT ラッパー コードの内容は、お互いを正確に反映する必要があり、最新のテンプレート コントラクト バージョンを反映する必要があります。

セッションのスキーマは、セッションのバージョン (メジャー バージョン) とプロトコルのバージョン (マイナー バージョン) によってバージョン管理されます。 バージョンは、"100 \* メジャー + マイナー" として X-Xbl-Contract-Version ヘッダーにまとめられます。 たとえば、v1.7 タイトルには、最新のテンプレート コントラクト バージョンが 107 であると仮定して、すべての REST 要求に X-Xbl-Contract-Version: 107 のヘッダーが含まれます。

| 注意                                                                                              |
|----------------------------------------------------------------------------------------------------------------|
| (XSAPI を使用する) ほとんどのタイトルで、コントラクト バージョン 105 とセッション テンプレート バージョン 107 を使用することをお勧めします。 |


### <a name="session-templates"></a>セッション テンプレート

各セッション テンプレートは、サービス構成に含まれる JSON ドキュメントであり、作成するセッションのフレームワークを定義し、新しいセッションに定数を提供します。 詳細については、「[MPSD セッション テンプレート](../service-configuration/session-templates.md)」を参照してください。

## <a name="session-capabilities"></a>セッション機能

機能は、MPSD がそのセッションに適用する動作を構成する、MPSD セッション内の定数です。 最もよく使用される XDP と Windows デベロッパー センターの機能、セッション テンプレートで設定します。 /constants/system/capabilities オブジェクトに設定されます。 機能が必要ない場合は、空の capabilities オブジェクトを使用します。

| 注意                                                                                                       |
|-------------------------------------------------------------------------------------------------------------------------|
| タイトルが Multiplayer WinRT API または Matchmaking WinRT API を使用してセッション機能を変更またはアクセスすることはほとんどありません。 |

セッション機能は、**MultiplayerSessionCapabilities クラス**によって表されます。 これらはセッションがサポートできるものを示すブール値です。

-   接続
-   ゲーム プレイ
-   大きいサイズ
-   アクティブなメンバーに必要な接続

**MultiplayerSessionConstants クラス**は、セッション機能に関連する以下のプロパティを定義します。

-   **CapabilitiesConnectivity**
-   **CapabilitiesGameplay**
-   **CapabilitiesLarge**

| 注意                                                                                                   |
|---------------------------------------------------------------------------------------------------------------------|
| タイトルで動的なセッション機能を定義する場合は、セッション定数の対応するプロパティを true に設定します。 |

## <a name="session-size"></a>セッション サイズ

MPSD セッションのサイズは、そのセッション内のメンバーの数によって決まります。


### <a name="maximum-session-size"></a>セッションの最大サイズ

セッションの最大サイズは対応できるセッション メンバーの最大数です。 これは **MultiplayerSessionConstants.MaxMembersInSession プロパティ**で表されます。 最大メンバー サイズは、/constants/system オブジェクトで設定されています。

最大セッション サイズは 1 ～ 100 の範囲であり、作成時に設定しなければ、既定値の 100 になります。 必要なサイズが 100 を超える場合、セッションは「大きな」セッションと呼ばれ、特別な方法で設定されます。

セッションの最大サイズを設定すると、特定の切断シナリオで、空きスロットが埋まっているように見える可能性があります。 たとえば、ネットワークまたは電源の障害によりプレイヤーが切断された場合、遅延はセッションに直ちに反映されません。 メンバーは、「[MPSD の変更通知処理および切断検出](multiplayer-session-directory.md)」で説明されている切断検出機能を使用して非アクティブに設定されます。

それに対し、ハートビートを使用して切断を検出するピア メッシュは、多くの場合、2 ～ 3 秒以内に切断を認識し、プレイヤー スロットを即時に開くことができます。 しかし、アービターは他のメンバーを削除できません。

### <a name="large-sessions"></a>大きなセッション

大きな MPSD セッションは最大 1000 のメンバーを持つことができますが、すべてのメンバー一覧の取得など、いくつかのセッション機能が無効になります。 セッションの大きさは、**MultiplayerSessionCapabilities.Large プロパティ**によって表されます。 大きなセッションを指定する場合はこのプロパティが true に設定され、"大きな" 機能は /constants/system/capabilities オブジェクトで示されます。 詳細については、「[セッション機能]()」を参照してください。

## <a name="session-user-states"></a>セッションのユーザーの状態



MPSD では、ユーザーの状態を、セッションに追加されたユーザーのステータスとして定義します。 ユーザーの状態は、**MultiplayerSessionStatus 列挙型**で定義されています。 また、ユーザーは、セッションに追加される前に "参加可能" のステータスを持つと見なされます。

**MultiplayerSession.SetCurrentUserStatus メソッド**を使用して、セッションのユーザーの状態を変更できます。 この変更は、REST に対して、ゲーム セッションの JSON ドキュメントで /members/{index}/properties/system を正しく設定することによって実行できます。


### <a name="reserved-user-state"></a>予約済みのユーザーの状態

アービターがセッション内の空きスロットの 1 つを埋めるためにユーザーを選択したとき、そのユーザーは予約済みのユーザーの状態になります。 この状態では、ユーザーはまだセッションへの招待を正式に受け入れていないか、またはピアとの接続を開始するためのセッションに参加していません。


### <a name="active-user-state"></a>アクティブなユーザーの状態

ユーザーがアクティブな状態の場合、タイトルがユーザーの代わりにセッションに参加し、ユーザーはセッションにアクティブに参加します。 ユーザーがゲームをプレイしている限り、この状態が継続されます。

タイトルでは、最初に起動したとき、通常はセッションの状態をチェックすることによって、ユーザーが既にいずれかのセッションのメンバーかどうかを確認する必要があります。 ユーザーがセッション メンバーである場合、タイトルはすぐにゲームに移行し、参加しているすべてのローカル メンバーのユーザーの状態をアクティブに設定することができます。

ユーザーは、セッションでプレイしている間はアクティブ状態を維持する必要があります。 ユーザーがゲーム内 UI でセッションを離れた場合、**MultiplayerSession.Leave メソッド**によってそのユーザーをセッションから削除する必要があります。 ユーザーが一時的にゲームを離れただけの場合は (タイトルが制限されたときのように)、タイトルは適切な時間だけユーザーをアクティブ状態に保つ必要があります。 タイトルで指定されている時間が経過してもユーザーが戻らない場合は、ユーザーの状態を非アクティブに変更してください。


### <a name="inactive-user-state"></a>非アクティブなユーザーの状態

非アクティブ状態では、ユーザーは現在はゲームに参加していませんが、まだセッション内のスロットを確保しています。 つまり、ユーザーは、"アクティブではない" 状態です。

ユーザーをセッションで非アクティブなユーザーの状態に設定する責任があるのは、そのユーザー自身の本体です。 アービターはこの処理を実行できません。 ユーザーが非アクティブ状態になるシナリオの例を以下に示します。

-   タイトルが Suspending イベントを受け取る。
-   タイトルによって定義された時間に渡ってユーザーの非アクティブ状態が続いた (入力またはコントローラーの応答がなかった)。 対戦型マルチプレイヤーの場合の推奨値は 2 分です。
-   タイトルが、2 分、またはタイトルで定義されている時間より長く制限モードになっている。 この制限モードのタイムアウト時間は、ユーザーが関連アプリまたはタイトルに関係する他のエクスペリエンスを使用してタイトルから離れると予想される時間です。
-   ユーザーがセッションから異常切断された。 「[MPSD の変更通知処理および切断検出](multiplayer-session-directory.md)」を参照してください。

タイトルが起動し、特定のセッション メンバーのユーザーの状態が非アクティブに設定されている場合、タイトルが一時停止されているか、セッションでユーザーが長い間非アクティブになっています。 タイトルが再び起動しようとしているので、ユーザーが、自分が所属するゲーム セッションの続行を望んでいることを示しています。 タイトルの起動時にユーザーの状態がアクティブの場合は、おそらく、ネットワークの切断、またはタイトルが中断される前にユーザーを非アクティブに設定できなかった他のシナリオが原因です。 タイトルではどちらの場合も、ユーザーをゲームおよび他のユーザーと再接続してプレイを続けさせるか、ユーザーをセッションから削除するよう試みる必要があります。

### <a name="user-state-when-the-session-is-over"></a>セッション終了時のユーザーの状態

セッションが終了すると、ゲーム プレイは中止されます。 タイトルは、**MultiplayerSession.Leave メソッド**を使用して、すべてのユーザーが自分自身を削除できるようにする必要があります。 セッションから抜けた場合、ユーザーに関連付けられているセッションのアクティビティは自動的にクリアされます。

## <a name="visibility-and-joinability"></a>可視性と参加可能性

セッション アクセスは、セッションの可視性およびセッションの参加可能性という 2 つの設定によって MPSD レベルで制御されます。 ここで示す可視性と参加可能性に関する推奨事項は、最も一般的なタイトル シナリオに適用されます。 タイトルでは、可能な限りこれらの設定に従うようにし、新しいプレイヤーにセッションへの参加を許可するかどうかについての最終的な正式決定をタイトル内ロジックを使用して行うようにします。


### <a name="session-visibility"></a>セッション可視性

セッションの可視性は、セッションの作成時に設定される定数で表されます。 この定数は、通常、セッション テンプレートで定義され、セッションに対する読み取りアクセスと書き込みアクセスができるユーザーの種類を決定します。 セッションの可視性で使用できる値は、**MultiplayerSessionVisibility 列挙型**によって定義されます。 JSON ファイルで可視性定数に許可される設定は、open、visible、および private です。


#### <a name="recommended-game-session-visibility-open"></a>ゲーム セッションの推奨される可視性: open

オープン状態のゲーム セッションでは、プレイヤーの予約を必要としないため、招待プロセスが簡素化されます。 アービターは、招待が送信された後に MPSD でプレイヤーを予約せず、招待されたプレイヤーのローカルでの追跡のみを行います。 したがって、プレイヤーはすぐにアービターに接続して、セッションに参加するか、拒否されるか、待機するか (待機中のプレイヤーがサポートされている場合) を判断できます。 アービターは最終的な権限を持っており、新しいメンバーに応答してセッションにとどまるか離れるかを指示します。

ゲーム セッションの可視性に open を使用すると、招待されたプレイヤーは、最終決定が行われる前にタイトルを起動してアービターに接続する必要があります。 セッションがいっぱいの場合、または招待が拒否された場合は、ユーザーにエラー メッセージを表示することができます。

アービターへの接続を確立するには、セキュア デバイス アドレスが必要です。 **MultiplayerSessionProperties.HostDeviceToken プロパティ**は、どのセッション メンバーがセッションの現在のアービターであるか、および招待されたプレイヤーが接続にどのセキュア デバイス アドレスを使用する必要があるかを確認するために使用されます。

### <a name="session-joinability"></a>セッションの参加可能性

セッションの参加可能性は、セッションに参加できるユーザーの種類を決定します。 これはセッション中に動的に設定できます。 セッションの参加可能性で使用できる値は次のとおりです。

-   None (既定) -- セッションに参加できるユーザーに関する制限はありません。
-   Local -- ローカル ユーザーのみがセッションに参加できます。
-   Followed -- ローカル ユーザーおよび他のセッション メンバーによってフォローされているユーザーのみが予約なしでセッションに参加できます。

セッションのアービターは、参加可能性の設定によってプライベート セッションを作成できます。 参加可能性を Local または Followed にすると、セッションへのアクセスが制限され、そのセッションはプライベートになります。

さらに、アービターは必要に応じて、セッションの参加可能性を追跡してホスト レベルで古いセッションへの招待を拒否できるようにする必要があります。 たとえば、セッションがいっぱいになるまで招待されたプレイヤーがセッションへの参加に至らなかった場合、アービターは、セッションがロックされており、セッションを離れる必要があることを、これから参加するプレイヤーに自動的に指示できます。

## <a name="session-timeouts"></a>セッション タイムアウト

タイマーおよびその他の外部イベントによってセッションを変更できます。 セッション タイムアウトでは、自動的に非アクティブになる、またはセッションから削除される前に、セッション メンバーが特定の状態を維持できる期間を定義します。 MPSD では、セッションの有効期間を管理するためのタイムアウトもサポートされます。

| 注意                                                                                                                                                                                                                                                           |
|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| テンプレート コントラクト バージョン 104/105 の場合、タイムアウトの設定は \constants\system\timeouts または初期化の管理オブジェクト内で行います。 107 以降のバージョンの場合、設定は \constants\system または初期化の管理オブジェクト内で個別に行います。 |

タイマーの期限が切れると、MPSD は自動的にはセッションを更新せず、変化が起きたその時点でアービターに通知します。 セッションおよびタイムアウト状態は、読み取りまたは書き込み要求が送信される直前にだけ更新されます。 直前に更新することで、返されるデータが確実に最新のものになります。

| 注意                                                                                                          |
|----------------------------------------------------------------------------------------------------------------------------|
| セッション タイムアウトはスタックされず、各セッション メンバーの更新時の状態遷移に対して 1 回だけ適用されます。 |


### <a name="currently-defined-timeouts"></a>現在定義されているタイムアウト

ここでは、MPSD で現在定義されているタイムアウトについて説明します。 すべてのタイムアウトはミリ秒単位で指定します。 即時のタイムアウトを示す 値 0 を指定できます。 値を持たないタイムアウトは無制限と見なされます。 タイムアウトには既定値があるため、タイムアウトを無期限にするには、null を明示的に指定してください。
#### <a name="evaluationtimeout"></a>evaluationTimeout

このタイムアウトは、セッション メンバーが評価の決定を行ってアップロードしなければならない時間を示します。 決定が受信されない場合、失敗としてカウントされます。 このタイムアウトは、初期化の管理オブジェクトに配置されます。


#### <a name="inactiveremovaltimeout"></a>inactiveRemovalTimeout

このタイムアウトは、セッションに参加しているが、現在はゲームに参加していないセッション メンバーに対して設定されます。 メンバーは、既定では 2 時間後にセッションから削除されます。

| 注意                                                                      |
|----------------------------------------------------------------------------------------|
| このタイムアウトは、テンプレート コントラクト バージョン 104/105 では非アクティブ タイムアウトと呼ばれています。 |

多くの場合、非アクティブ タイムアウトは 0 に設定することをお勧めします。これにより、非アクティブ状態に設定されたユーザーは、すぐにセッションから削除されて、対応するスロットはクリアされます。 この動作は、ユーザーが非アクティブになるか非アクティブ状態に達した場合に、新しいプレイヤーをすぐに追加できるので、ほとんどの対戦型マルチプレイヤー ゲームに適しています。 協力型またはその他のマルチプレイヤー設計のタイトルでは、ユーザーが切断された場合またはしばらくタイトルに参加していない場合に、ユーザーが再接続できる時間をもう少し長くすることをお勧めします。 すべての設計シナリオに適合する単一のソリューションはありません。

#### <a name="jointimeout"></a>joinTimeout

このタイムアウトは、ユーザーがセッションに参加しなければならないミリ秒数を示します。 参加に失敗したユーザーの予約は削除されます。 このタイムアウトは、初期化の管理オブジェクトに配置されます。


#### <a name="measurementtimeout"></a>measurementTimeout

このタイムアウトは、セッション メンバーが測定値をアップロードしなければならない時間を示します。 測定値のアップロードに失敗したメンバーには、失敗理由として "タイムアウト" が設定されます。 このタイムアウトは、初期化の管理オブジェクトに配置されます。

| 注意                                                                                                                                                                              |
|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| マッチメイキング中に、QoS 測定に 45 秒間のタイムアウトが適用されます。 したがって、マッチメイキング中に 30 秒以内の測定タイムアウトを使用することをお勧めします。 |


#### <a name="readyremovaltimeout"></a>readyRemovalTimeout

このタイムアウトは、セッションに参加していて、ゲームに参加しようとしているセッション メンバーに対して設定されます。 これは通常、シェルがタイトルに代わってユーザーを参加させ、タイトルが起動中であることを意味します。 メンバーは、セッションから削除され、既定では、3 分後に非アクティブ状態になります。

| 注意                                                          |
|----------------------------------------------------------------------------|
| このタイムアウトは、コントラクト バージョン 104/105 では準備完了タイムアウトと呼ばれています。 |


#### <a name="reservedremovaltimeout"></a>reservedRemovalTimeout

このタイムアウトは、他のユーザーによってセッションに追加されたが、まだセッションに参加していないセッション メンバーに対して設定されます。 タイムアウト時間が経過すると、予約は削除され、メンバーは非アクティブと見なされます。 既定値は 30 秒です。

| 注意                                                             |
|-------------------------------------------------------------------------------|
| このタイムアウトは、コントラクト バージョン 104/105 では予約タイムアウトと呼ばれています。 |


#### <a name="sessionemptytimeout"></a>sessionEmptyTimeout

このタイムアウトは、セッションが空になってから削除されるまでのミリ秒数を示します。 既定値は 0 です。

| 注意                                                                 |
|-----------------------------------------------------------------------------------|
| このタイムアウトは、コントラクト バージョン 104/105 では sessionEmpty タイムアウトと呼ばれています。 |


### <a name="session-timeout-example"></a>セッション タイムアウトの例

1.  4 人のプレイヤーでセッションが開始されます。
2.  2 人のプレイヤー A と B が電源障害によって切断されます。 ゲーム内で A と B の状態は Active のままです。
3.  他の 2 人のプレイヤー C と D は、**MultiplayerSession.Leave メソッド**を使用して正しく終了します。
4.  プレイヤー A と B は切断されていますがまだ Active 状態であるため、セッションは開いたままになります。
5.  数日後、プレイヤー A が戻ってゲームを開始します。
6.  プレイヤー A のゲームは、A がメンバーであるセッションをチェックし (読み取りを実行し)、孤立した数日前のセッションを見つけます。
7.  セッションは、まだセッション内にいる 2 人のプレイヤー (A および B) に対して、プレゼンスのチェックを行います。
    1.  プレイヤー A はタイトルを実行しているので、プレイヤー A に対するプレゼンス チェックは成功し、マッチ内のプレイヤーの Active 状態は変わりません。
    2.  プレイヤー B は、タイトルを実行していません。 したがって、プレイヤー B のプレゼンス チェックは失敗し、サービスはプレイヤー B の状態を非アクティブに設定します。 この時点で、プレイヤー B に対する非アクティブ タイムアウトが開始します。

8.  プレイヤー A は、**Leave** メソッドを使用して正しくセッションを終了します。
9.  プレイヤー B の非アクティブ タイムアウトが経過し、プレイヤー B はだれかによる次の読み取りまたは書き込み時にセッションから削除されます。
10. セッションは、メンバーが 0 になったので、サービスから削除されます。

例のセッションの非アクティブ タイムアウトが 0 に設定されている場合、プレイヤー B は、手順 7a でのプレゼンス チェックの直後にタイムアウトし、セッション書き込みによっておそらく削除されます。 この場合、セッションは、セッションへの追加の読み取りまたは書き込みがなくても閉じられます。


## <a name="multiple-signed-in-users-on-a-single-console"></a>1 台の本体にサインインした複数のユーザー


同じ本体に複数のユーザーがサインインした場合、ゲーム セッションに含まれるユーザーと、ゲーム セッションに含まれないユーザー、または現在のタイトルでアクティブではないユーザーが混在することがあります。 複数のユーザーがゲームの招待を受け取って受け入れる場合もあり、ゲーム セッションのメンバーシップに影響があります。 タイトルでは、これらの点を考慮し、セッション メンバーシップのすべてのシナリオを正しく処理できる必要があります。

一般的なシナリオでは、新しいプレイヤーがサインインし、ゲームでアクティブになり、既存のゲーム セッションに追加される必要があります。 新しいゲーム セッションの作成と同様に、タイトルはゲーム プレイ中の適切なときにのみ、ユーザーを追加する必要があります。

サインインしたユーザーが複数いる場合、その中の 1 人以上が別のゲーム セッションへの招待を受け取ることもあります。 タイトルではこのようなシナリオを特定の方法で処理する必要はありません。 セッションの状態およびメンバーのイベントが、ゲーム セッションおよびユーザー メンバーシップに対するすべての更新をタイトルに通知します。

オンライン セッションにサインインした複数のユーザーを処理するために、タイトルはユーザーごとに別々の **XboxLiveContext クラス** オブジェクトを使用して、すべてのユーザーについてショルダー タップをサブスクライブします。 タイトルは **MultiplayerSession.ChangeNumber プロパティ**を使用してセッションの特定の変更を確認して、重複ショルダー タップを無視します。


## <a name="process-lifecycle-management"></a>プロセス ライフサイクル管理


非マルチプレイヤー タイトルと同様に、マルチプレイヤー セッション内のタイトルで、タイトルの一時停止やプロセス ライフサイクル イベントの終了が発生することがあります。 したがって、セッション アービターは定期的にセッション状態を保存する必要があります。 アービターが一時停止された場合、タイトルはアービターの移行を試みて、新しいアービターがセッションの状態を復元できるように、必要に応じてゲーム状態を保存する必要があります。 セッションが MPSD でまだ有効である限り、マルチプレイヤー セッション全体を一時停止し、後で再開することができます。 指定されているただ 1 つのピア (通常はゲーム ホスト) が、グローバルなゲーム状態を更新する必要があります。


### <a name="storage-of-game-metadata"></a>ゲーム メタデータのストレージ

タイトルは、MPSD セッション内にゲーム メタデータを格納します。 ゲーム メタデータは、セッション データを表示し、タイトルがゲーム セッションを見つけて参加できるようにするために必要な情報です。 タイトルはプレイヤー固有のメタデータ (プレイヤーの色、プレイヤーがセッションで優先的に使用する武器など) をそのセッション メンバーのカスタム プロパティ セクションに保存します。現在のマップなどのセッション全体のメタデータは、MPSD セッションのグローバル カスタム プロパティ セクションに保存されます。


### <a name="storage-of-game-state"></a>ゲーム状態のストレージ

ゲームの状態は、**タイトル ストレージ サービス**を使用してタイトル管理ストレージ (TMS) に保存されます。 この場所を使用するストレージにより、タイトルはアクセス許可の問題なしにアービターを移行できます。 「[アービターの移行](migrating-an-arbiter.md)」を参照してください。

| 注意                                                                                                               |
|---------------------------------------------------------------------------------------------------------------------------------|
| タイトルが、一時停止されている場合を除き、5 分に 1 回よりも高い頻度で TMS にゲーム状態を保存しないようにしてください。 |

## <a name="cleanup-of-inactive-sessions"></a>非アクティブなセッションのクリーンアップ

sessionEmptyTimeout が 0 に設定されている場合、最後のプレイヤーがセッションを離れると、MPSD セッションは自動的に削除されます。 クラッシュ後または切断後に未使用のセッションにプレイヤーが含まれないようにする方法を調べるには、「[MPSD の変更通知処理および切断検出](multiplayer-session-directory.md)」を参照してください。 クラッシュ後または切断後に未使用のセッションが不適切に処理されると、タイトルがプレイヤーのセッションをクエリするときに問題が発生する可能性があります。

非アクティブなセッションをクリーンアップするための推奨される方法は、タイトルで **MultiplayerService.GetSessionsAsync メソッド**を呼び出してからセッションを評価することによって、特定のユーザーのすべてのセッションをクエリすることです。 古いセッションを検出すると、タイトルはセッション内のすべてのローカル プレイヤーに対して **MultiplayerSession.Leave メソッド**を呼び出します。 この呼び出しは最終的にメンバー数を 0 まで減らし、セッションをクリーンアップします。

## <a name="session-arbiter"></a>セッション アービター


一部のマルチプレイヤー メソッドは、ゲーム セッション内の 1 つのクライアントによってのみ呼び出される必要があります。 このクライアントは、セッションに参加している本体の 1 つで、アービター、またはホストと呼ばれます。 少なくとも 1 人のセッション メンバーがゲームにいる場合、セッションには途中参加を監視するアービターが必要です。


### <a name="setting-the-arbiter"></a>アービターの設定

セッションの作成時に、クライアントはアービターとして 1 つの本体を指定します。 「[方法: MPSD セッションのアービターの設定](multiplayer-how-tos.md)」を参照してください。


### <a name="saving-session-state"></a>セッション状態の保存

「**プロセス ライフサイクル管理**」で説明されているように、アービターはセッション状態を定期的に保存する必要があります。 タイトルによるアービターの移行の場合、新規のアービターはセッション状態を復元できる必要があります。 詳細については、「[アービターの移行](multiplayer-how-tos.md)」を参照してください。


### <a name="managing-game-session-members-and-joins-in-progress"></a>ゲーム セッションのメンバーと途中参加の管理

セッション アービターの最も重要な役割は、プレイするためにゲーム セッションに新しく加わるユーザーの管理です。 これには、ゲームへの招待の処理、待機中のプレイヤーへの通知、ゲームを終了するプレイヤーに対する操作が含まれます。


#### <a name="receiving-notifications"></a>通知の受信

アービターは、**RealTimeActivityService.MultiplayerSessionChanged イベント**で、ゲーム セッションへの参加を希望している新しいプレイヤーをリッスンする必要があります。


#### <a name="finding-players-to-fill-empty-game-session-slots"></a>ゲーム セッションの空スロットを埋めるプレイヤーの検索

アービターは以下のいずれかの操作を行って、ゲーム セッションの空スロットを埋めるプレイヤーを検索します。タイトルがロビー セッションまたは別のメカニズムを使用して途中参加を許可する場合は、そのメカニズムを使用して新しいセッション メンバーを検索します。
-   別のマッチ チケット セッションを作成します。

詳細については、「[方法: マッチメイキング中に空きセッション スロットを埋める](multiplayer-how-tos.md)」を参照してください。


#### <a name="handling-invited-session-members"></a>招待されたセッション メンバーの処理

アービターは、招待されたセッション メンバーを監視し、1 人のユーザーに対する招待間の最小間隔を適用する必要があります。 「[方法: ゲームへの招待の送信](multiplayer-how-tos.md)」も参照してください。
