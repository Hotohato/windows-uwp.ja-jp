---
title: アリーナ タイトル統合ガイド
author: KevinAsgari
description: タイトルに Xbox Live アリーナ プラットフォームのサポートを組み込む方法について説明します。
ms.assetid: 470914df-cbb5-4580-b33a-edb353873e32
ms.author: kevinasg
ms.date: 09-14-2017
ms.topic: article
ms.prod: windows
ms.technology: uwp
keywords: Xbox Live, Xbox, ゲーム, UWP, Windows 10, Xbox One, アリーナ, トーナメント
ms.localizationpriority: medium
ms.openlocfilehash: 12654a89cc43c323c4fa516c4d78f15553441671
ms.sourcegitcommit: 106aec1e59ba41aae2ac00f909b81bf7121a6ef1
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 10/15/2018
ms.locfileid: "4617453"
---
# <a name="arena-title-integration-guide"></a>アリーナ タイトル統合ガイド

## <a name="introduction"></a>はじめに

Xbox の アリーナ プラットフォームでは、トーナメント主催者 (TO) が、アリーナ対応のタイトルからトーナメントを作成して運営することができます。 アリーナは、Xbox Live TO をサポートして、発行元やユーザーによるトーナメントの実行を可能にするだけでなく、アリーナと連携するサードパーティの TO もサポートします。 シングル エリミネーション (勝ち抜きトーナメント) やスイス ドローなど、トーナメントのスタイルは TO が決定します。

このトピックでは、タイトル開発者を対象に、タイトルにアリーナのサポートを実装する手順を説明します。 アリーナ対応に設定したゲームは、TO が選択した、サポートされている任意のトーナメント形式に従って動作します。 TO はトーナメントの構造に従って、タイトルのマッチを編成します。 これを受けてアリーナ対応のタイトルは、ゲーム内の各マッチに適切なユーザーを配置し、マッチ結果を TO に報告します。

## <a name="overview"></a>概要

Xbox アリーナでは、Xbox のマルチプレイヤー ゲーム開発で一般的な概念が使われています。 Xbox マルチプレイヤー システムに慣れていない場合は、このガイドを読み進める前に、それに関するドキュメントを確認することをお勧めします。 プロセスは、ユーザーがマルチプレイヤー ゲームへの招待を受け入れるプロセスに似ています。 アリーナ トーナメントでユーザーのマッチの準備ができると、ユーザーに通知するトーストが別ウィンドウで表示されます。 ユーザーがトーストを承諾すると、タイトルはアリーナの標準のプロトコルのアクティブ化イベントを受信します。 タイトルがまだ実行されていない場合は、この時点で起動されます。

トーナメント マッチ自体の調整には、マルチプレイヤー セッション ディレクトリ (MPSD) セッションが使用されます。 アリーナの場合、このセッションは、タイトルによってではなく、アリーナ プラットフォームによって作成されます。 セッションの作成には、セッション テンプレートに加え、タイトル発行元が作成した追加のゲーム構成が使われます。 トーナメント マッチ参加者は、この時点で既にこのセッションに参加しています。 タイトル発行元は、アリーナが結果報告の判定をサポートするために使用するセッション テンプレートを構成する必要があります。 このセッションのすべての要件については、このガイドで後ほど説明します。 タイトルはまた、その他のセッションを必要に応じて自由に作成することもできます。

タイトルは、このセッションを使って、マッチを設定し、結果をレポートします。 タイトルがアリーナに対応するためには、少なくとも、プロトコルのアクティブ化に対応し、MPSD セッションとやり取りするための統合が必要です。 トーナメントの参照とトーナメントへの登録は、Xbox アリーナ UI を通じてサポートされます。 タイトルは、必要に応じてトーナメント ハブ サービスからトーナメントに関する追加情報を取得して、さらに充実したタイトル内エクスペリエンスを実現できます。 たとえば、タイトルはトーナメント ハブを使用して、チーム名などのコンテキストを表示したり、ユーザーの新しいマッチ セッションを検索したりすることができます。 次の図では、このデータ フローを緑の矢印で示します。このデータ フローについて詳しくは、「[エクスペリエンス要件とベスト プラクティス](#experience-requirements-and-best-practices)」のセクションで説明します。 薄い色の矢印は、ユーザーがトーナメント内のマッチ間を移動し、それによって時間と共にチームからセッションへの参照が変化することを示しています。

![](../../images/arena/tournament-flow.png)


アリーナ プロトコルのアクティブ化 URI には、トーナメントや、マッチのセッション、マッチ終了時にタイトルが起動できるディープ リンクに関する情報が含まれています。 ディープ リンクは、ユーザーを Xbox アリーナ UI に戻すためのリンクです。 これらの URI のコンポーネントについて詳しくは、「[アリーナ統合の基本的要件](#basic-requirements-for-arena-integration)」の「[プロトコルのアクティブ化](#protocol-activation)」のセクションをご覧ください。

## <a name="basic-requirements-for-arena-integration"></a>アリーナ統合の基本的要件

ここでは、アリーナのサポートに必要な最小限の要件を使用してタイトルを統合するための、技術的なガイダンスと詳細情報を示します。 このスタイルの統合は、次の概略図でオレンジ色の矢印で示されているデータ フローを利用します。

![](../../images/arena/arena-data-flow.png)

タイトルでのプロトコルのアクティブ化は、Xbox アリーナ UI から実行されます。 これは、トースト通知、トーナメントの詳細ページのほか、マッチへのあらゆるエントリ ポイントから発生します。 ユーザーがマッチに参加するときは、次のステップが実行されます。

1.  Xbox アリーナ UI によって、タイトルでプロトコルがアクティブ化されます。
2.  タイトルでアクティブ化パラメーターを使って、シングル マッチがプレイされます。
3.  マッチが終了したら、タイトルが MPSD ゲーム セッションに結果を報告します。
4.  タイトルに、ユーザーがアリーナ UI に戻るためのオプションが表示されます。

以降の各セクションでは、これらの各ステップについて詳しく説明します。

### <a name="1--protocol-activation"></a>1. プロトコルのアクティブ化

ユーザーのマッチの準備が整ったら、アリーナ UI によってタイトルのプロトコルがアクティブ化され、マッチが開始します。 プロトコルのアクティブ化には、この時点でタイトルを起動する場合と、既にタイトルが実行されている場合の 2 つの場合があります。 いずれの場合も、ユーザーがマルチプレイヤー ゲームへの招待を受け入れ、それに対応してタイトルがアクティブ化される場合と同様に処理されます。

#### <a name="if-your-title-is-launched-at-the-time-of-protocol-activation"></a>プロトコルのアクティブ化の時点で、タイトルが起動される場合

**Activated** イベントは、タイトルの起動時に初めて発生します。 その最初のアクティブ化がアリーナのプロトコルのアクティブ化である場合、タイトルを起動したのは、トーナメントでプレイをしようとしているユーザーです。 したがって、タイトルは、メニューとログイン画面をバイパスして、できるだけ迅速にマッチにスキップする必要があります。 また参加ユーザーの Xbox ユーザー ID (XUID) がアクティブ化 URI に提供されるため、ログインが既に完了しています。

#### <a name="if-your-title-is-already-running"></a>タイトルが既に実行されている場合

**Activated** イベントは、タイトルが既に実行されているときに、アリーナ プロトコルのアクティブ化と共に生成することもできます。 **Activation** イベントは、明示的なユーザー操作 (マッチを通知するトーストへの操作、または Xbox アリーナ UI からマッチへの切り替え) によってのみトリガーされます。 タイトルが、メニュー画面で待機している場合は、すぐにトーナメント マッチにジャンプする必要があります。 またゲームプレイ中にタイトルがプロトコルのアクティブ化を受け取った場合は、ユーザーに対し、最も効率的な方法でゲームを終了して、トーナメント マッチに移動するオプションを表示します。 必要に応じて、プレイ中のゲームを保存するオプションをユーザーに提供します。

プロトコルのアクティブ化は、`CoreApplicationView.Activated` イベントを介してタイトルに配信されます。 このイベントの `IActivatedEventArgs.Kind` プロパティが `Protocol` に設定されている場合、アクティブ化はプロトコルのアクティブ化であり、引数を`ProtocolActivatedEventArgs` クラスにキャストすることができます。この場合、プロトコルのアクティブ化 URI が `Uri` プロパティを介して提供されます。

タイトルで、プロトコルのアクティブ化 URI の XUID を確認します。 さらにそれが現在のプレイヤーと一致しない場合、タイトルでユーザー コンテキストを切り替える必要があります。

#### <a name="the-protocol-activation-uri"></a>プロトコルのアクティブ化 URI

この URI のテンプレートは次のとおりです。

```URI
ms-xbl-multiplayer://tournament?action=joinGame&joinerXuid={memberId}&organizer={organizerId}&tournamentId={tournamentId}&teamId={teamId}&scid={scid}&templateName={templateName}&name={name}&returnUri={returnUri}&returnPfn={returnPfn}
```

本体で ERA タイトルが実行されている場合、アクティブ化スキームが若干異なります。

```
ms-xbl-{titleIdHex}://
```

これは招待の場合と同じです。 このために、タイトル ID は、8 桁の 16 進数文字でなければならず、必要に応じて先頭にゼロが挿入されます。

まず `Uri.Host` (区切り文字 “://” の直後の名前) が “tournament” であることを確認します。 この部分によって、アリーナのプロトコルのアクティブ化が他の機能のアクティブ化 (ゲームへの招待など) から区別されます。

クエリ文字列の引数は URL エンコードされ、大文字小文字が区別されます。 タイトルは、パラメーターの順序に依存してはなりません。また認識されていないパラメーターを無視する必要があります。


パラメーター | 説明
--- | ---
**action** | 操作は "joinGame" のみがサポートされています。 **action** が指定されていないか、別の値が指定されている場合は、アクティブ化を無視します。
**joinerXuid** | **joinerXuid** は、トーナメント マッチでプレイしようとしているログイン ユーザーの XUID です。 タイトルでは、このユーザーのコンテキストに切り替えられる必要があります。 **joinerXuid** がログインしていない場合、タイトルはアカウント ピッカーを表示して、ユーザーにログインを促す必要があります。 XUID は、常に 10 進数で表されます。
**organizerId、tournamentId** | **organizerId** と **tournamentId** の組み合わせは、マッチが関連付けられているトーナメントの一意の識別子となります。 トーナメントに関する詳細な情報をタイトルに表示する場合は、この識別子を使ってトーナメント ハブから情報を取得できます。
**teamId** | **teamId** は、トーナメントのコンテキストで、(**joinerXuid** パラメーターで指定された) ユーザーの所属チームを示す一意の識別子です。 **organizerId** パラメーターと **tournamentId** パラメーターの組み合わせと同様、必要に応じて、**teamId** を使ってトーナメント ハブからチームに関する情報を取得できます。
**scid、templateName、name** | 組み合わせて使用して、セッションを識別できます。 セッションへの MPSD URI パスで指定されているのと同じ 3 つのパラメーターです。</br> </br>`https://sessiondirectory.xboxlive.com/serviceconfigs/{scid}/sessiontemplates/{templateName}/sessions{name}`.</br></br>XSAPI では、これらは `multiplayer_session_reference ` コンストラクターを指す 3 つのパラメーターです。
**returnUri、returnPfn** | **returnUri** は、ユーザーを Xbox アリーナ UI に戻すためのプロトコルのアクティブ化 URI です。 **returnPfn** パラメーターは、指定されていない場合もあります。 指定されている場合は、**returnUri** を処理するためのアプリの製品ファミリ名 (PFN) です。 これらの値の使用方法を示すサンプル コードについては、「[Xbox アリーナ UI への復帰](#returning-to-the-xbox-arena-ui)」をご覧ください。

### <a name="2--playing-the-match"></a>2. マッチの実行

トーナメント主催者が MPSD セッションを作成すると、ユーザーはそのセッションの非アクティブなメンバーとして設定されます。 タイトルでは `multiplayer_session::join()` を使用して、すぐにプレイヤーをアクティブに設定する必要があります。 これにより、Xbox Live および他のユーザーに対して、対象のユーザーがタイトル内に存在し、プレイの準備ができていることが示されます。

マッチの開始時刻は、セッション内の `/servers/arbitration/constants/system/startTime` で、標準 UTC 形式の日付と時刻の値を使って指定されます (たとえば、"2009-06-15T13:45:30.0900000Z")。 1703 XDK 以降の XSAPI では、開始時刻が `multiplayer_session_arbitration_server::arbitration_start_time()` で指定されます。 TO は、開始時刻前にいつでも (または開示時刻と同時に) セッションを作成できます。 マッチ通知は開始時刻にマッチ参加者に送信されるため、タイトルが開始時刻より前にアクティブ化されることはありません。 またマッチの結果報告は、開始時刻になって初めて MPSD によって許可されます。

タイトルは、各メンバーの `/member/{index}/constants/system/team` プロパティ (`multiplayer_session_member::team_id()`) を確認して、各ユーザーが所属するチームを判断します。

タイトルはまたセッションを使用して、マップやモードなどのマッチの設定を把握します。 これらのタイトル固有の設定は、セッション テンプレートで設定するか、トーナメント定義の中でカスタムの定数として設定できます  (詳しくは、「[アリーナ向けのタイトルの構成手順](#configuring-a-title-for-arena)」をご覧ください)。次に例を示します。

```json
{
    "constants": {
        "custom": {
            "enableCheats": false,
            "bestOf": 3,
            "map": "winter-fall",
            "mode": "capture-the-throne"
        }
    }
}
```

これらの設定は、`multiplayer_session_constants::session_custom_constants_json()` API を使って、セッションから JavaScript Object Notation (JSON) オブジェクトとして取得できます。

一般に、タイトルは、それ自体の MPSD セッションと同じ方法でアリーナ セッションを処理します。 たとえば、ハンドルを作成し、RTA 通知をサブスクライブすることができます。 ただし、違いがいくつかあります。 たとえば、タイトルは、ゲーム セッションの参加者名簿を変更できず、セッションのサービスの品質 (QoS) 機能を使用できません。また、判定に参加する必要があります。 セッションについて詳しくは、このガイドで後ほど説明します。

### <a name="3--reporting-results"></a>3. 結果の報告

マッチの結果は、判定と呼ばれる機能を使って、セッション経由で アリーナ と TO に報告されます。 判定は、セッションを使って安全にマッチをプレイし、結果を報告するフレームワークです。

プロトコルのアクティブ化のステップでタイトルに提供されるセッションは、判定済みセッションとなります。これは、判定フレームワークが適用する固定タイムラインを持つセッションです。 次の図に、判定のタイムラインを示します。

![](../../images/arena/arbitration-timeline.png)

失効時刻 (開始時刻に失効タイムアウト時間を加えた時刻) の前に、セッション内で少なくとも 1 人のプレイヤーがアクティブである必要があります (`multiplayer_session_arbitration_server::arbitration_start_time()`)。失効タイムアウトは、セッション内の `/constants/system/arbitration/forfeitTimeout` (`multiplayer_session_constants::forfeit_timeout()`) に、ミリ秒単位で指定します。 失効時刻までに参加済みのアクティブなプレイヤーがいない場合、マッチはキャンセルされます。

判定タイムアウトは、`/constants/system/arbitration/arbitrationTimeout` (`multiplayer_session_constants::arbitration_timeout()`) にミリ秒で指定します。 判定時刻は、開始時刻に判定タイムアウト時間を加えた時刻であり、プレイヤーはこの時刻までにマッチを完了して結果を報告する必要があります。 この値は、発行元が、セッション テンプレートまたはゲーム モードで設定します。 この値は、タイトルでマッチを完了するために必要な時間を自由に設定できます。

タイトルは、開始時刻から判定時刻までの間、いつでも結果を報告できます。 判定は、失効時刻から判定時刻までの間に、セッションのすべてのアクティブなメンバーの結果が送信された後で随時実行されます。 たとえば、失効時にアクティブなメンバーが 1 人だけのセッションでも、メンバーは結果を投稿でき (または投稿しなければならず)、判定が行われます。 判定は、判定時刻までに報告された結果の数に関係なく、既に実行済みでない限り実行されます。 判定時刻に結果が 1 つも提出されていない場合、マッチのすべての参加者が敗者と判定されます。

またゲーム サーバーは、判定済みの結果を書き込むだけで、いつでも判定を強制できます。

ユーザーが既に判定済みのセッションにいる場合 (判定タイムアウトに達した場合や、ゲーム サーバーがセッションを判定する場合、またはユーザーの参加が遅れた場合)、タイトルはマッチを終了し、判定結果をユーザーに表示します。

判定結果には、常に、すべてのチームの結果が含まれます。 個々のプレイヤーがセッションに結果を書き込むと、自分のチームの結果だけでなく、すべてのチームの完全な結果のセットが判定結果に含まれます。

JSON では、結果が次のように記述されます。

```json
"results": {
    "red": {
        "outcome": "rank",
        "ranking": 1
    },
    "blue": {
        "outcome": "rank",
        "ranking": 2
    }
}
```

この例で、チーム ID は “red” と “blue” です。 red チームが 1 位、blue チームが 2 位です。 **outcome** の値には、この他に次の値を使用できます。

* “win”
* “loss”
* “draw”
* “noshow”

**outcome** が “rank” 以外の場合、そのチームの順位が省略されます。

個々のユーザーは、マッチの結果を `/members/{index}/properties/system/arbitration` (`multiplayer_session::set_current_user_member_arbitration_results()` に書き込みます。 以下では、タイトルがチームベースでない場合 (つまり、すべてのプレイヤーが 1 人のチームに属する場合) に、タイトルを構築し、結果セットを提出する方法の例を示します。

```c++
void Sample::SubmitResultsForArbitration()
{
    std::unordered_map<string_t, tournament_team_result> results;

    for (auto& member : arbitratedSession->members())
    {
        tournament_team_result teamResult;
        teamResult.set_state(tournament_game_result_state::rank);
        teamResult.set_ranking(memberRank);

        results.insert(std::pair<string_t, tournament_team_result>(
            member->team_id(),
            teamResult));
    }

    arbitratedSession->set_current_user_member_arbitration_results(results);
    xboxLiveContext->multiplayer_service().write_session(
arbitratedSession,
multiplayer_session_write_mode::update_existing)
    .then([](xbox_live_result<std::shared_ptr<multiplayer_session>> sessionResult)
    {
        if (sessionResult.err())
        {
            // Handle error.
        }
        else
        {
            // Update local session cache.
        }
    });
}
```

判定が行われた後、MPSD は最終結果を、以下に示す他の少数のプロパティと共に `/servers/arbitration/properties/system`(`multiplayer_session::arbitration_server()`) に配置します。

```json
{
    "resultState": "completed”,
    "resultSource": "arbitration",
    "resultConfidenceLevel": 75,

    "results": { ... }
}
```

**resultState** に格納できる値は次のとおりです。

* “completed”: すべてのアクティブなプレイヤーが結果を報告しました。
* “partialresults”: 判定タイムアウトの前に、全部ではないが一部のプレイヤーが結果を報告しました。
* “noresults”: 判定タイムアウトの前に、結果を報告したプレイヤーはいませんでした。
* “canceled”: 失効タイムアウトまでに、アクティブなプレイヤーが 1 人も参加しませんでした。

“noresults” と “canceled” の場合は、結果が省略されます。

個々のプレイヤーが報告する結果に基づいて MPSD が判定を行う場合、**resultSource** が “arbitration” に設定されます。 ゲーム サーバーは、判定をバイパスして /servers/arbitration/properties/system 自体に書き込むことができます。 その場合、**resultSource** が "server" に設定されます。 ゲーム サーバーが結果を書き換える (修正または調整する) こともできます。その場合、**resultSource** が “adjusted” に設定されます。

**resultConfidenceLevel** は、結果の合意レベルを示す 0 ～ 100 の整数です。 100 は、すべてのプレイヤーが同意していることを意味します。 0 は合意がなく、基本的には、提出された結果からランダムに選択された結果であることを意味します。 ゲーム サーバーが判定結果を設定しているときは、**resultConfidenceLevel** が通常、100 に設定されます。しかし、なんらかの理由でゲーム サーバーの判定が確実でない場合 (ゲーム サーバー自体の機能によって、プレイヤーによる投票手続きの結果を報告している場合など) は、異なる数値が設定されることもあります。 **resultConfidenceLevel** は、調整結果の信頼度を反映して結果が調整された場合にも設定します。

**resultSource** が “arbitration” の場合 (かつ、**resultState** が “completed” または “partialresults” の場合)、提供される結果は、プレイヤーが報告した結果の少なくとも 1 つの正確なコピーです。

### <a name="4--returning-to-the-xbox-arena-ui"></a>4. Xbox アリーナ UI への復帰

マッチの終了時には (または進行中のマッチの破棄を求めるプレイヤーの要求に対応して)、プレイヤーが、マッチの参加時に使った Xbox アリーナ UI に戻るためのオプションを表示します。 これは、マッチ終了後の結果画面またはその他の任意のゲーム終了 UI に表示します。

アリーナ UI に戻るには、`Windows::System::Launcher` クラスを使って、プロトコルのアクティブ化 URI から渡された **returnUri** を起動します。 必ずユーザー コンテキストを含めてください。

ERA ゲームに対しては、起動 API の動作が、ユニバーサル Windows プラットフォーム (UWP) ゲームに対する場合とは若干異なります。 ERA バージョンの API では PFN を指定できないため、アクティブ化 URI で PFN が指定されていても無視されることがあります。

ERA でユーザーをアリーナ UI に戻すためのコード例を次に示します。

```c++
void Sample::LaunchReturnUi(Uri ^returnUri, Windows::Xbox::System::User ^currentUser)
{
    auto options = ref new LauncherOptions();
    options->Context = currentUser;

    Launcher::LaunchUriAsync(returnUri, options);
}
```

UWP ゲームでは、プロトコルのアクティブ化 URI で戻り PFN が指定されている場合、**LauncherOptions** の **TargetApplicationPackageFamilyName** プロパティをその戻り PFN に設定できます。 これにより特定のアプリが起動され、そのアプリがまだインストールされていない場合は、ユーザーが Store に誘導されます。

UWP アプリでユーザーを アリーナ UI に戻すためのコード例を次に示します。

```c++
void Sample::LaunchReturnUi(Uri ^returnUri, String ^returnPfn, User ^currentUser)
{
    auto options = ref new LauncherOptions();

    if (returnPfn != nullptr)
    {
        options->TargetApplicationPackageFamilyName = returnPfn;
    }

    Launcher::LaunchUriForUserAsync(currentUser, returnUri, options);
}
```

アリーナ UI を呼び出した後、タイトルは (おそらくは同じ画面で) 引き続き実行され、別のプロトコルのアクティブ化イベントが発生するまで待機します。 これにより、プレイヤーが別のマッチでプレイする場合に、タイトルがすぐに対応できます。 その結果、プレイヤーがタイトルと Xbox アリーナ UI を切り替えて、マッチ間をスピーディに移動でき、迅速なユーザー エクスペリエンスが実現します。

### <a name="handling-errors-and-edge-cases"></a>エラーおよびエッジ ケースの処理

前のセクションのフローは、問題なくマッチをプレイできる場合のパスについて説明しています。 しかし、予期しない動作が生じたり、問題が発生したりする可能性のある箇所は数多く存在します。 このセクションでは、いくつかの潜在的なエラーやエッジ ケースを取り上げ、タイトル内での推奨される処理方法を示します。

#### <a name="game-session-not-found"></a>ゲーム セッションが見つからない

マッチへのセッション参照によってタイトルを起動していて、クライアントがそのセッションを MPSD から要求する際にエラーが発生した場合は、マッチに参加できないことを示すエラーをユーザーに表示します。

#### <a name="user-attempts-to-join-a-match-that-has-been-played"></a>ユーザーが既にプレイしたマッチに参加を試みている

結果が既に報告された後でユーザーがマッチに参加しようとした場合は、クライアントが新しいマッチを開始できないように阻止し、ユーザーにエラーを表示します。 セッションのメンバーを反復処理して、`/members/{index}/arbitrationStatus` (`multiplayer_session_member::tournament_arbitration_status`) が “complete” に設定されているメンバーをチェックすることで、結果が報告済みかどうかを確認できます。

#### <a name="game-clients-unable-to-establish-a-p2p-connection"></a>ゲーム クライアントが p2p 接続を確立できない

タイトルで、マルチプレイヤー対応のためにクライアント間でユーザー間 (p2p) 接続を使用しているが、リレーがサポートされない場合、マッチングされたユーザーが p2p 接続を確立できない可能性があります。

クライアントがマッチのセッションは取得できるが、他のクライアントに接続できない場合、`/members/{index}/properties/system/arbitration/results`(`multiplayer_session::set_current_user_member_arbitration_results()`) で各チームに対して "draw" (引き分け) の結果を報告します。 Xbox Live に対しては、マッチが実行されなかったものとして処理されます。 またこれにより、強制的に p2p 接続エラーを発生させてトーナメントを進めようとする不正行為も防止できます。

#### <a name="game-client-disconnects-mid-match"></a>ゲームのクライアントが、マッチの途中で切断される

最も一般的なエラー状況の 1 つが、マッチのプレイ中にクライアントが切断されるというエラーです。 このケースを処理する方法については、マッチと実装の状態に応じていくつかの選択肢があります。

* トーナメント マッチが 1 対 1 の場合、またはチームのすべてのメンバーが他のクライアントやゲーム サービスから切断された場合、切断されたチームを "loss" (敗者) として報告することをお勧めします。 これにより、敗色濃厚なユーザーが、結果の報告を阻止しようとして強制的に切断することを防止できます。
* 複数メンバーのチーム間のマッチで、一部のチーム メンバーがマッチの途中で切断された場合は、その時点でマッチを終了するか、残りのメンバーでマッチを続けるかを選択できます。 マッチを続行する場合、切断されたユーザーにマッチへの再参加を許可するという選択肢も考えられます。

#### <a name="full-teams-not-present"></a>チーム メンバーが揃わない

複数メンバーのチーム間のマッチをサポートするタイトルの場合、チームの一部のメンバーが、タイトルを起動できずマッチに参加できないことがあります。 この場合、それらのチーム メンバーを除いたチームでプレイを許可することができます。さらに、アクセスできないメンバーがゲームの進行中に途中参加できるように設定することもできます。

または、このマッチに対して、結果を強制適用することもできます。 その場合、forfeitTimeout に達するまで待ち、すべての参加者に参加の機会を確保したうえで結果を適用します。 これにより、タイトルを更新する必要なしに、トーナメントのゲーム モードを変更してウィンドウを調整できます。

#### <a name="length-of-match-exceeds-arbitrationtimeout"></a>マッチの長さが arbitrationTimeout を超えている

**arbitrationTimeout** の値を、マッチの最大所要時間よりも大きい値に設定します。 しかし、タイトルのモードによっては、マッチの所要時間が非常に長くなることがあり、最大時間がないこともあります。 このような場合は、次のいずれかの方法を検討します。

* トーナメントのプレイを固定の最大時間があるモードに制限する。
* 時間制限をユーザーに通知し、マッチ内で同点決勝ゲームを行って **arbitrationTimeout** までに結果を報告する。

**arbitrationTimeout** が期限切れになると、マッチ結果が自動的にトリガーされるため、**arbitrationTimeout** 期間の経過を待ってタイトルから結果を報告することはできません。  代わりに、バッファー時間を設定するか (**arbitrationTimeout** - 1000 ミリ秒など)、別の値を使ってマッチの最大長を制御します。

#### <a name="other-cases"></a>それ以外の場合

その他のエラーについては、一般的な対処方法として、ユーザーにエラーを通知して Xbox アリーナ UI に戻します。

## <a name="experience-requirements-and-best-practices"></a>エクスペリエンス要件とベスト プラクティス

アリーナではタイトルが個別のマッチとしてのみ提示されるため、タイトルを更新せずに、徐々に新しい形式を導入できます。 そのため、アリーナに統合されるタイトルの基準ユーザー エクスペリエンスには、複数の対戦形式に対応できる単純さと柔軟性が必要です。

必要に応じて、トーナメント ハブのユーザー データをタイトルで使用すると、トーナメントをゲーム内エクスペリエンスと緊密に統合することができます。  この機能は、"xbox::services::tournaments" に用意されています。  これらの API を使うと、次の処理を実行できます。
* タイトル の UI にトーナメントの詳細情報を表示できます (トーナメント名、チーム名など)。
* タイトル内でトーナメントの情報を提供できます。
* アリーナのマッチとマッチの間、ユーザーをタイトル内に維持できます。

## <a name="configuring-a-title-for-arena"></a>タイトルをアリーナ対応として構成する手順

タイトルをアリーナ対応として構成するには、Xbox デベロッパー ポータル (XDP) またはユニバーサル デベロッパー センター (UDC) で構成タイトルを構成する際に、次の追加の手順を実行する必要があります。

### <a name="enabling-arena-for-your-title"></a>タイトルでのアリーナの有効化

アリーナを有効にするには、XDP でタイトルのサービス構成ページに移動して "アリーナ" を選択します。

![](../../images/arena/arena-configure-xdp.png)

ここには、複数のオプションが用意されています。

* **[Arena Enabled]** (アリーナを有効にする): このサンド ボックスでアリーナを有効にするには、このチェック ボックスをオンにします。
* **[Arena Features]** (アリーナ 機能): このセクションには、ユーザー作成トーナメントをサンドボックス内で有効にするチェックボックスと、クロス プレイ (異なるプラットフォームを使用する複数のユーザーが同じトーナメントに参加できる機能) を有効にするチェック ボックスがあります。
* **[Arena Platforms]** (アリーナ プラットフォーム): タイトルのトーナメントをプレイできるプラットフォームを選択できます。
* **[Tournament Assets]** (トーナメントのアセット): (従来、[Multiplayer and Matchmaking] (マルチプレイヤーとマッチメイキング) のセクションにあった項目)。これらはタイトルのトーナメント イメージです。

アリーナは、Xbox Live サービスの**トーナメント**のメニューで、Windows デベロッパー センターでも有効にすることができます。

![Windows デベロッパー センターでのアリーナ メニュー](../../images/arena/Arena_On_WDC.JPG)

変更を有効にするには、サービス構成を公開する必要があります。 現在、UDC を介したセルフ サービスのアリーナの構成はサポートされていません。 サービス構成に UDC を使用している場合は、アリーナの導入についてデベロッパー アカウント マネージャにご相談ください。

### <a name="setting-up-game-modes"></a>ゲーム モードの設定

ゲーム モードは、発行元がトーナメント マッチの設定を事前に構成できる Xbox Live の機能です。 これらのゲーム モードにより、トーナメントの作成時に、Xbox Live とタイトルがトーナメントに適用しているルールが設定されます。 タイトルでユーザー作成トーナメントを有効にするには、発行元が 1 つ以上のゲーム モードを設定する必要があります。 ゲーム モードには次の要素があります。

#### <a name="supports-ugt"></a>UGT 対応または非対応

ユーザー作成トーナメント (UGT) で使用するゲーム モードを有効にすることができます。 タイトルが UGT をサポートする場合、ゲーム モードをオンにすると、Xbox Live ユーザーがこのタイトルでトーナメントを作成する際にゲーム モードを選択できます。

#### <a name="team-size"></a>チームの規模

チームとしてトーナメントに参加できるユーザーの数です。 シングル ユーザーのタイトルまたはトーナメントでは、ゲーム モードのチーム サイズは 1 です。 アリーナは、現時点で、トーナメントでのチーム規模の変更をサポートしていません。

#### <a name="forfeittimeout"></a>forfeitTimeout

マッチの開始時刻後、プレイヤーが 1 人も参加しない場合 (つまり、プレイヤーがセッションで自分をアクティブに設定しない場合) に、マッチがキャンセルされるまでの時間の長さです (ミリ秒単位)。 少なくとも、プレイヤーがトースト通知を受け取ってタイトルを起動し、トーナメント マッチに参加できる十分な時間を設定してください。

#### <a name="arbitrationtimeout"></a>arbitrationTimeout

マッチの開始時刻後、結果の受け付けを締め切るまでの時間の長さ (ミリ秒単位) です。 失効タイムアウト時間とマッチの最大所要時間の合計よりも長い時間を設定します。 これにより、失効時刻直前にプレイを開始したプレイヤーも、マッチを完了することができます。 **arbitrationTimeout** の時間内に結果が報告されない場合、マッチの参加者全員が敗者となります。 Xbox アリーナはまた、**arbitrationTimeout** までの間すべてのアクティブ メンバーが結果を報告するのを待ち、その後、判定を開始します。

このタイムアウトは、問題が発生してプレイヤーが結果を報告できない場合の安全弁として機能します。 このタイムアウトを設定することで、トーナメント全体を停止するのではなく、トーナメントが結果を待つ最大時間が設定されます。 したがって、この値によって各トーナメント ラウンドの最大時間が決まるため、過度に大きな値を設定しないように注意してください。

#### <a name="name"></a>名前

ユーザーに表示されるゲーム モード名です。 この値はローカライズ可能です。

#### <a name="description"></a>説明

ユーザーに表示されるゲーム モードの説明です。 この値はローカライズ可能です。

#### <a name="custom"></a>カスタム設定

ゲーム モードの **custom** セクションは、開発者がトーナメント マッチに関するタイトル固有のあらゆる構成設定を挿入できるプロパティ バッグです。 カスタム セクションの一部として定義される値は、`/properties/custom/` のマッチ MPSD セッションに書き込まれます。

現時点では、XDP または UDC を介したゲーム モードのセットアップはサポートされていません。 タイトルのゲーム モードを作成するには、担当のデベロッパー アカウント マネージャーにご連絡ください。

### <a name="requirements-for-the-session-template"></a>セッション テンプレートの要件

タイトル デベロッパーは、TO がマッチ セッションの作成時に使用するセッション テンプレートを提供する必要があります。 このテンプレートには、いくつか必要な設定値があります。

```json
{
    "version": 1,
    "inviteProtocol": "tournamentGame",
    "memberInitialization": null,

    "capabilities": {
        "gameplay": true,
        "arbitration": true,

        "large": false,
        "broadcast": false,
        "blockBadMsaReputation": false
    },

    "maxMembersCount": {maxMembersCount},
}
```

必要に応じて、これ以外のプロパティも設定できます。

アリーナ セッションは、常に、バージョン 1 です。 **inviteProtocol** を “tournamentGame” に設定して、トーナメント参加者にマッチの準備完了通知を送信します。 **memberInitialization** は null に設定して QoS を無効にします。 これはマッチのセッションであるため、ゲームプレイ機能をオンにします。判定機能は、結果の報告に必要です。 **large**、**broadcast**、**blockBadMsaReputation** の各機能は、セッションの動作を阻害するため無効にします。

タイトルでは、このテンプレートを使用するすべてのトーナメントに固定の値を適用する設定項目について、テンプレートの custom セクションに固有の設定値を指定できます。 次に例を示します。

```json
        "custom": {
            "enableCheats": false,
            "bestOf": 3
        }
```

最後に、**maxMembersCount** システム設定が必要です。 これには、トーナメント マッチでプレイできるプレイヤーの合計数を設定します。 プレイヤーの数は、ゲーム モードの設定によってさらに制限できるため、セッションで設定する値には、必ずタイトルでサポートされる最大プレイヤー合計数を設定してください。 たとえば、ゲームが 1 回のマッチで最大 5 人対 ５ 人のプレイヤーをサポートする場合は、**maxMembersCount** を 10 に設定します。 この MPSD テンプレートを使用した場合、**maxMembersCount** を上限として、任意の数のプレイヤーのマッチがサポートされます。
