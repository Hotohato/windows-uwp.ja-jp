---
xxxxx: Xxx xxxxxxxx
xxxxxxxxxxx: Xxx, xx xxxx x xxxx xx xxx xxx xxxx xxxxxx xxxxxxxxxx xxxx-xxxx xxxxxxxx xx x Y-X xxxx, xxx xxx xx xxxxxxx xxxxx xxxxx, xxxxx, xxx xxxx xxxxxxxxxx xxxxxxxx.
xx.xxxxxxx: xYYYYxxx-YYYx-YYxY-xxYx-xxYYxYxYYYxY
---

# Xxx xxxxxxxx


\[ Xxxxxxx xxx XXX xxxx xx Xxxxxxx YY. Xxx Xxxxxxx Y.x xxxxxxxx, xxx xxx [xxxxxxx](http://go.microsoft.com/fwlink/p/?linkid=619132) \]

Xxx, xx xxxx x xxxx xx xxx xxx xxxx xxxxxx xxxxxxxxxx xxxx-xxxx xxxxxxxx xx x Y-X xxxx, xxx xxx xx xxxxxxx xxxxx xxxxx, xxxxx, xxx xxxx xxxxxxxxxx xxxxxxxx.

## Xxxxxxxxx


-   Xx xxxxxxxxx xxxxx/xxxxxxxx, xxxxx, xxx Xxxx xxxxxxxxxx xxxxxxxx xx x Xxxxxxxxx Xxxxxxx Xxxxxxxx (XXX) xxxx xxxx XxxxxxX.

## XXX xxxx xxxx xxx xxxxxxxx


X xxxx XXX xxxx xxxxxxxx x xxxxx xxxxxxx xx xxxxxxxxxx. X xxxxxxxxx xxxxxx xxxxx xxxx Xxxxxxx YY xx x xxxxxx xxxx xx xxxxxxxx xxxxxxx, xx x xxxxx XX xxxx xx Xxxx xxxxxxxxxx xxxxxxxx, xx xxx xxxxxx xxxxxxx xxxxxx xxx xxxx x xxxx-xxxxxxxxxxx xxxxx xxx xxxxxx xxxxxxxx. Xxxx xxxx xxxxxx xxxxxxx xxx xx xxxxx xxxxxxx xx xxx xxxx xxxxxx xxxxxx xx.

Xxxx xxxxxx xxxxxxxx xxx xxxxx. Xx'x x xxxxxx xxxxx-xxxxxx xxxxxxxx xxxx, xxx xxx xxxx-xxxx xxxxxxxx xxxx xxx xxxxxxxx xxx xxxx xxxxx xxx xxxxxx xxxxxxxxxxx xxx xxx xxxxx xxxxx xx xxxxx.

Xxx xxxx xxxx xxxxx xxxxxxxx, xxx xxxx-xxxx xxxxxxxx xxxxxxxxxxxx, xxx [Xxxx-xxxx xxxxxxxx xxx xxxxx](tutorial--adding-move-look-controls-to-your-directx-game.md) xxx [Xxxxx xxxxxxxx xxx xxxxx](tutorial--adding-touch-controls-to-your-directx-game.md).

## Xxxxxx xxxxxxx xxxxxxxxx


Xxxxx xxxxxxxx xxx xxxxx/xxxxxxxx xxxxxxxx xxxx x xxxx xxxxxxx xxxx xxxxxxxxxxxxxx. Xx x XXX xxx, x xxxxxxx xx xxxxxx x xxxxx xx xxx xxxxxx. Xxx xxx xxxx xx xx xxxxxxx xxx xxxxx xx xxxxxxx xxxx xxxxxx xx xxx xxxxx xxxxxx. Xx x xxxxxx, xxx xxx xxxxxxxx xxx x xxxxxx xxx xx xxxxxx, xxx xxx xxxxx xxxxx xxxxxxx xxx xxxxxx xx xxxxx x xxxxx xx x xxxxx xxxxxx xx xxxx xxx xxxxx xxx xxxxxxx.

Xxxx xxx **XxxxXxxxXxxxxxxxxx** xxxxx xx xxx xxxx xxxxxx xx xxxxxxxxxxx, xx xxxxxxxxx xxx xxxx xxxxxxx-xxxxxxxx xxxxxx xxx xxx xxxxx-xxxxxxxx xxxxx:

-   [
            **XxxxXxxxxx::XxxxxxxXxxxxxx**](https://msdn.microsoft.com/library/windows/apps/br208278). Xxx xxxx xx xxxxx xxxxx xxxxxx xxx xxxxxxx (xxx xxxx), xx xxx xxxxx xxxxxxx xxx xxxxxxx.
-   [
            **XxxxXxxxxx::XxxxxxxXxxxx**](https://msdn.microsoft.com/library/windows/apps/br208276). Xxx xxxxx xxxxx, xx x xxxx xxxxxx xxx xxxx xx xxx xxxxx xxxxxxx.
-   [
            **XxxxXxxxxx::XxxxxxxXxxxxxxx**](https://msdn.microsoft.com/library/windows/apps/br208279). Xxx xxxx xxxxx xxxxxx xxx xxxxxxxx, xx xxx xxxxxx xxxxxxxxxx xxx xxxxx xxxxxxx xxx xxxxxx.
-   [
            **XxxxXxxxxx::XxxxxxxXxxxxx**](https://msdn.microsoft.com/library/windows/apps/br208275). Xxx xxxxxxx xxxxx xxx xx xxx xxxx xxxxxx.
-   [
            **Xxxxxxx::Xxxxxxx::Xxxxx::XxxxxXxxxx**](https://msdn.microsoft.com/library/windows/apps/hh758356). Xxx xxxxx xxxxx x xxxxxxx xxxxxxxx. Xx xxxxx xxxx xx xxx xxxx xxxxxxxxxx xx xxxxx xxxxxxxx xxxxx xxxxxx, xxx xxx xxx xxxxxxx x-x xxxxxxxx.

```cpp
void MoveLookController::Initialize(
    _In_ CoreWindow^ window
    )
{
    window->PointerPressed +=
        ref new TypedEventHandler<CoreWindow^, PointerEventArgs^>(this, &MoveLookController::OnPointerPressed);

    window->PointerMoved +=
        ref new TypedEventHandler<CoreWindow^, PointerEventArgs^>(this, &MoveLookController::OnPointerMoved);

    window->PointerReleased +=
        ref new TypedEventHandler<CoreWindow^, PointerEventArgs^>(this, &MoveLookController::OnPointerReleased);

    window->PointerExited +=
        ref new TypedEventHandler<CoreWindow^, PointerEventArgs^>(this, &MoveLookController::OnPointerExited);

    window->KeyDown +=
        ref new TypedEventHandler<CoreWindow^, KeyEventArgs^>(this, &MoveLookController::OnKeyDown);

    window->KeyUp +=
        ref new TypedEventHandler<CoreWindow^, KeyEventArgs^>(this, &MoveLookController::OnKeyUp);

    // A separate handler for mouse only relative mouse movement events.
    Windows::Devices::Input::MouseDevice::GetForCurrentView()->MouseMoved +=
        ref new TypedEventHandler<MouseDevice^, MouseEventArgs^>(this, &MoveLookController::OnMouseMoved);

    ResetState();
    m_state = MoveLookControllerState::None;

    m_pitch = 0.0f;
    m_yaw   = 0.0f;
}
```

Xxx Xxxx xxxxxxxxxx xx xxxxxxx xxxxxxxxxx, xxxxx xxx [XXxxxx](https://msdn.microsoft.com/library/windows/desktop/hh405053) XXXx. Xx xxxx xxxxx xxx xxxxxxxxxxxxxx xx xxxx xxxxxxxxxx xxxxxxxx xx x xxx.

Xx xxx xxxx xxxxxx, xxx **XxxxXxxxXxxxxxxxxx** xxxxx xxx xxxxx xxxxxxxxxx-xxxxxxxx xxxxxx, xxxxxxxxxx xx xxx xxxxxxx xxxx:

-   **Xxxx**. Xxxx xx xxx xxxxxxxxxxx xxxxx xxx xxx xxxxxxxxxx. Xxx xxxx xx xxx xxxxxxxxxxxx xxx xxxxxxxxxx xxxxx.
-   **XxxxXxxXxxxx**. Xxx xxxx xx xxxxxx xxx xx xxxxxxx xxx xxx xxxxxx xx xxxxxxxx.
-   **Xxxxxx**. Xxx xxxx xx xxxxxxx, xxxxxxxxxx xxxxxx xxxxx.

Xxx **Xxxxxx** xxxxx xx xxx xxxxx xxxx xxx xxxxxx xx xxxxxxxx xxxxxxx xxx xxxx. Xxxxxx xxxx xxxxx, xxx **XxxxXxxxXxxxxxxxxx** xxxxxxxx xx xxxxxxxxxx xxxxx xxxxxx xxxx xxx xxxxxxx xxxxx xxxxxxx xxx xxxxxxxxxxxx xxx xxxxxx'x xxxxxxxxxx xxxxx xx xxx xxxxxxxxxx xxxxx xxxx. Xx x xxxxxx, xx xxxxxxx xxx xxxxxxxx xxx xxxx xxxxxxxxx (xxx xxxx xxxxx xxxxxx) xx xxx xxxxxx'x xxxx xxx xxxxxx xxx xxxxxxx xxxx xxxx xxx xxxx xxxxx Xxxxxx xx xxxxxx xxxx xxx xxxx xxxx.

Xx xxxxx xxxx xxx xxxxxx xxx xxxx xxxx xxxx xxx xxxxxx xx xxx xxxx xxxx. Xxx xxxxxxx, xx xx xxx xxxxx xx xxxxxx xxxxxxx xxxxx xxxxxx xxx xxxxxx. Xxx xx xxxxx xxxxxx xxx xxxxxxx xx xxx **Xxxxxx** xxxxx, xxxx xxxxxxxxx xxxxxxx XXx xxxxxxxxxxxxx xx xxxxxxxxx xxxxxxx xxxxxxx. Xxxx xx xxxxxxxxx xxxxxxx xxxx x xxxxxx'x xxxxxxxxxxx, x xxxxxxx xxxxx xx xxx xxxxxx xxxxxxxxx xx xxxxxxxxx xxxx xxx xx xxx xxxx xxxxxxxxx xx xx xxx xxxx xx xxx xxxxxx.

Xxxx x [**XxxxxxxXxxxxxx**](https://msdn.microsoft.com/library/windows/apps/br208278) xxxxx xx xxxxxxxx, xxx **XxxxXxxxXxxxxxxxxx** xxxxxxx xxx xxxxxxx XX xxxxx xxxxxxx xx xxx xxxxxx. Xxx xxxxxxx XX xxxxxxxxxx x xxxxxxxx xxxx xx xxxxx. Xxx xxxxxxx, xx x xxxxx-xxxxx xxxxxx, xxxxx xxx xx xxxxxxx xxxxxxxxx xxxxxx xxxxxx xx xxx xxxx xxxx. Xxx XXx xxx xxxx xx xxxx xxxxx xx xxxxx xxxxx xxx xxxxxx xx xxxxx. Xx xxx xxxxx xx xx xxx xxxx xxxxxxxxx xx xxx xxxxx xxxxxx, x xxxxxxx XX xx xxxxxxxx xx xxxxx xxx xxxxxxx xxxxxx xx xxxx xxxxxxxxx. Xxxxx xxxxxxx xxxxxx xx xxx xxxx xxxxxxxxx xxx xxxxxxx xxxxxxxxxx, xxxx x xxxxxxxx xxxxxxx XX. (Xx xxxx xxxxx xxxx xxxx xxxx xx xxx xxxxxxx xx xxxxx xxxxxxxx.)

Xxxxx xxxx xxx xxxxx xxx xxx xxxxxxx XX xxx xx xxxx xxxxxxx xxxxxxxxxx.

Xxxxx xxx xxxxxxx xxxxxx xxxx xxxx xxxxxx xx x xxxxxxxx xxxx xxxxxx, xx'x xxxx xx xxxxxx xxx xxxx xxx **XxxxXxxxXxxxxxxxxx** xxxxxx xxxxxx xxxx xxx xxxx xxxx xxxx.

Xxxx xxxxxx, xxx **Xxxxxx** xxxxxx xx xxx xxxx xxxxxx xxxxxxxxx xxx xxxxx xxx xxxxxxx xxx xxxxxxxx xxx xxxx xxxxxxxxx xxxxxxxxx (**x\_xxxxxxxx** xxx **x\_xxxxxxxxxxxxx**), xxxxx xxx xxxx xxxx xxxx xxxxxxxxx xx xxxxxxx xxx xxxxxx **Xxxxxxxx** xxx **XxxxXxxxxxxxx** xxxxxxx xx xxx **XxxxXxxxXxxxxxxxxx** xxxxxxxx.

```cpp
void MoveLookController::Update()
{
    UpdateGameController();

    if (m_moveInUse)
    {
        // Move control.
        XMFLOAT2 pointerDelta;

        pointerDelta.x = m_movePointerPosition.x - m_moveFirstDown.x;
        pointerDelta.y = m_movePointerPosition.y - m_moveFirstDown.y;

        // Figure out the command from the virtual joystick.
        XMFLOAT3 commandDirection = XMFLOAT3(0.0f, 0.0f, 0.0f);
        if (fabsf(pointerDelta.x) > 16.0f)         // Leave 32 pixel-wide dead spot for being still.
            m_moveCommand.x -= pointerDelta.x/fabsf(pointerDelta.x);

        if (fabsf(pointerDelta.y) > 16.0f)
            m_moveCommand.y -= pointerDelta.y/fabsf(pointerDelta.y);
    }

    // Poll our state bits set by the keyboard input events.
    if (m_forward)
    {
        m_moveCommand.y += 1.0f;
    }
    if (m_back)
    {
        m_moveCommand.y -= 1.0f;
    }
    if (m_left)
    {
        m_moveCommand.x += 1.0f;
    }
    if (m_right)
    {
        m_moveCommand.x -= 1.0f;
    }
    if (m_up)
    {
        m_moveCommand.z += 1.0f;
    }
    if (m_down)
    {
        m_moveCommand.z -= 1.0f;
    }

    // Make sure that 45deg cases are not faster.
    if (fabsf(m_moveCommand.x) > 0.1f ||
        fabsf(m_moveCommand.y) > 0.1f ||
        fabsf(m_moveCommand.z) > 0.1f)
    {
        XMStoreFloat3(&m_moveCommand, XMVector3Normalize(XMLoadFloat3(&m_moveCommand)));
    }

    // Rotate command to align with our direction (world coordinates).
    XMFLOAT3 wCommand;
    wCommand.x =  m_moveCommand.x * cosf(m_yaw) - m_moveCommand.y * sinf(m_yaw);
    wCommand.y =  m_moveCommand.x * sinf(m_yaw) + m_moveCommand.y * cosf(m_yaw);
    wCommand.z =  m_moveCommand.z;

    // Scale for sensitivity adjustment.
    // Our velocity is based on the command, y is up.
    m_velocity.x = -wCommand.x * MOVEMENT_GAIN;
    m_velocity.z =  wCommand.y * MOVEMENT_GAIN;
    m_velocity.y =  wCommand.z * MOVEMENT_GAIN;

    // Clear movement input accumulator for use during next frame.
    m_moveCommand = XMFLOAT3(0.0f, 0.0f, 0.0f);
}
```

Xxx xxxx xxxx xxx xxxx xx xxx xx xxx xxxxxx xx xxxxxx xx xxxxxxx xxx **XxXxxxxx** xxxxxx xx xxx **XxxxXxxxXxxxxxxxxx** xxxxxxxx. Xxx **XxxxXxxxXxxxxxxxxx** xxxxxx xx xxx xx xxx xxxxxx xxx xxxxxxx xxx xxxx xxxxxx xx xxx xx xxx xxxxx xxxxx xxxxx.

```cpp
bool MoveLookController::IsFiring()
{
    if (m_state == MoveLookControllerState::Active)
    {
        if (m_autoFire)
        {
            return (m_fireInUse || (m_mouseInUse && m_mouseLeftInUse) || m_xinputTriggerInUse);
        }
        else
        {
            if (m_firePressed)
            {
                m_firePressed = false;
                return true;
            }
        }
    }
    return false;
}
```

Xx xxx xxxxxx xxxxx xxx xxxxxxx xxxxxxx xxx xxxx xxxxxx xx xxx xxxx, xx xxxxxxx xxx xxxxx xxxxxx (xxx X xxx xx xxx Xxxx xxxxxxxxxx xxxxx xxxxxx), xxx xxxx xxxx xx xxxxxx. Xxx **XxxxXxxxXxxxxxxxxx** xxxxxxxxxx xxx xxxxx, xxx xxxxxxx xxx xxxx xxxx xxxx xx xxxxx xxx **XxXxxxxXxxxxxxxx** xxxxxx. Xx xxxx xxxxx, xx **XxXxxxxXxxxxxxxx** xxxxxxx **xxxx**, xxx xxxx xxxx xxxx xxxxx **XxxxXxxXxxxx** xx xxx **XxxxXxxxXxxxxxxxxx** xx xxxx xxx xxxxxxxxxx xxxx xxx **XxxxXxxXxxxx** xxxxx. Xxxx, xxx **XxxxXxxxXxxxxxxxxx** xxxxx xxx xxx xxxxxx xx xxxxxx xxx xx xxx xxxx xxxxx xx xxxx, xxxxxxxx, xx xxxx xxx xxxx, xxx xxxx xxxxxxxxxx xxxxxxxx xxxxx xxxxxx xxxxx xx xxxxxxx xx xxx **Xxxxxx** xxxxx.

Xxx xxx [xxxxxxxx xxxx xxxxxx xxx xxxx xxxxxxx](#code_sample).

Xxx, xxx'x xxxx xx xxx xxxxxxxxxxxxxx xx xxxx xx xxx xxxxx xxxxxxx xxxxx xx x xxxxxx xxxx xxxxxx.

## Xxxxxxxxxxxx xxxxxxxx xxxxx xxxxxxxx


Xx xxxxx xxxxxxxx xx xxxxxxxx, xx xxxx xxx xxxx xxxxxxxx xx xxxxxxxxx xxx xxx xxxxx xxx xxx xx xxx xxxxxx. Xx xx xxxx xx xxxxxxxxxxxx xxxxxxxx xxxxx xxxxxxxx, xxxxx xx xxxxxx xxx xxxxxxxx xxxxxxxx xxx xxxxx xxx xxxxx—xxx xxxxx xxxxxxx xxx xxxxx xx xxx xxxxxxxx xxx xxx xxxx—xx xxxxxxx xx xxxxxxxxx xxx xxxxxxxx x-x xxxxx xxxxxxxxxxx xx xxx xxxxxx.

Xx xx xxxx, xx xxxxxx xxx xxxxxxx xx xxx X (xxx xxxxxxxxxx xxxxxx) xxx xxx X (xxx xxxxxxxx xxxxxx) xxxxxxxxxxx xx xxxxxxxxx xxx [**XxxxxXxxxx::X**](https://msdn.microsoft.com/library/windows/apps/hh758353) xxx **XxxxxXxxxx::X** xxxxxx xx xxx [**Xxxxxxx::Xxxxxx::Xxxxx::XxxxxXxxxxXxxx::XxxxxXxxxx**](https://msdn.microsoft.com/library/windows/apps/hh758358) xxxxxxxx xxxxxx xxxxxxxx xx xxx [**XxxxxXxxxx**](https://msdn.microsoft.com/library/windows/apps/hh758356) xxxxx.

```cpp
void MoveLookController::OnMouseMoved(
    _In_ MouseDevice^ /* mouseDevice */,
    _In_ MouseEventArgs^ args
    )
{
    // Handle Mouse Input via dedicated relative movement handler.

    switch (m_state)
    {
    case MoveLookControllerState::Active:
        XMFLOAT2 mouseDelta;
        mouseDelta.x = static_cast<float>(args->MouseDelta.X);
        mouseDelta.y = static_cast<float>(args->MouseDelta.Y);

        XMFLOAT2 rotationDelta;
        rotationDelta.x  = mouseDelta.x * ROTATION_GAIN;   // scale for control sensitivity
        rotationDelta.y  = mouseDelta.y * ROTATION_GAIN;

        // Update our orientation based on the command.
        m_pitch -= rotationDelta.y;
        m_yaw   += rotationDelta.x;

        // Limit pitch to straight up or straight down.
        float limit = XM_PI / 2.0f - 0.01f;
        m_pitch = __max(-limit, m_pitch);
        m_pitch = __min(+limit, m_pitch);

        // Keep longitude in same range by wrapping.
        if (m_yaw >  XM_PI)
        {
            m_yaw -= XM_PI * 2.0f;
        }
        else if (m_yaw < -XM_PI)
        {
            m_yaw += XM_PI * 2.0f;
        }
        break;
    }
}
```

## Xxxxxxxxxxxx xxxxx xxxxxxxx


Xxxxx xxxxxxxx xxx xxx xxxxxxxxx xx xxxxxxx, xxxxxxx xxxx xxx xxx xxxx xxxxxxx xxx xxxxxxx xxx xxxx xxxx-xxxxxx xx xx xxxxxxxxx. Xx xxx xxxx xxxxxx, x xxxxxxxxx xx xxx xxxxx xxxx xxxxxxxx xx xxx xxxxxx xx xxxx xx x xxxxxxxxxxx xxx, xxxxx xxxxxxx xxxx xxxxx xxxx xxx xxxxx xx xxxx xxxxx xxxxxx xxx xxxxxx xxxx xxx xxxxx, xxx xxxxxxx xxxx xxxxx xx xxx xxxx xxxxx xxx xxxxxx xxxxxxx xxx xxxxxxxx. X xxxxxxxxx xx xxx xxxxx xxxxx xxxxxxxx xx xxx xxxxxx xxx xx xxxxxxx xx xxxx xxx xxxxxxx. Xxxxxx (xxxxx xxx xxx) xxx xxxxxxxxxx xx xxxxxxx xxxx xxxxxx xx xxx xxxxx xx xxx xxxxxx xxx xxxxxxxx xxx xxxxxx xxx xxxxxx; xx xxxx xxxxxx xxxxx, xxx xxxxxx (xxxx xxxxx xxxxx xxxxx) xxxxx xxxxxxxxx.

Xxx xxxx xxx xxxx xxxxxxxxxx xxx xxxxxxx xx xxx xxxxxxx xx xxx xxxxxx xxxx:

```cpp
void SetMoveRect(
        _In_ DirectX::XMFLOAT2 upperLeft,
        _In_ DirectX::XMFLOAT2 lowerRight
        );
 void SetFireRect(
        _In_ DirectX::XMFLOAT2 upperLeft,
        _In_ DirectX::XMFLOAT2 lowerRight
        );
```

Xx xxxxx xxxxx xxxxxx xxxxxxx xxxxxx xxx xxx xxxxx xxxxxxx xx xxx xxxxxx xx xxxx xxxxxxxx. Xx xxx xxxxxx xx xxxxxxx, xxxxx xxxxxxxxxx xxxx xx xxxxxxxx xxxxx (xxx xxxxxxx).

Xx x xxxxx xxxxxx xxxxxxx xxxxx xx xxxxxx xx xxx xx xxxxx xxxxxxx xxx xxx xxxx xxxxx xx xxx xx **Xxxxxx**, xx'x xxxxxxxx x xxxxxxx XX, xx xx xxxxxxxxx xxxxxxx.

```cpp
void MoveLookController::OnPointerPressed(
    _In_ CoreWindow^ sender,
    _In_ PointerEventArgs^ args
    )
{
    PointerPoint^ point = args->CurrentPoint;
    UINT32 pointerID = point->PointerId;
    Point pointerPosition = point->Position;
    PointerPointProperties^ pointProperties = point->Properties;
    auto pointerDevice = point->PointerDevice;
    auto pointerDeviceType = pointerDevice->PointerDeviceType;

    XMFLOAT2 position = XMFLOAT2(pointerPosition.X, pointerPosition.Y);     // convert to allow math

    switch (m_state)
    {
    case MoveLookControllerState::WaitForInput:
        // ...
        // Game is paused, wait for click inside the game window.
        // ...
        break;

    case MoveLookControllerState::Active:
        switch (pointerDeviceType)
        {
        case Windows::Devices::Input::PointerDeviceType::Touch:
            // Check to see if this pointer is in the move control.
            if (position.x > m_moveUpperLeft.x &&
                position.x < m_moveLowerRight.x &&
                position.y > m_moveUpperLeft.y &&
                position.y < m_moveLowerRight.y)
            {
                if (!m_moveInUse)         // If no pointer is in this control yet:
                {
                    // Process a DPad touch down event.
                    m_moveFirstDown = position;                 // Save the location of the initial contact.
                    m_movePointerID = pointerID;                // Store the pointer using this control.
                    m_moveInUse = true;
                }
            }
            // Check to see if this pointer is in the fire control.
            else if (position.x > m_fireUpperLeft.x &&
                position.x < m_fireLowerRight.x &&
                position.y > m_fireUpperLeft.y &&
                position.y < m_fireLowerRight.y)
            {
                if (!m_fireInUse)
                {
                    m_fireLastPoint = position;
                    m_firePointerID = pointerID;
                    m_fireInUse = true;
                }
            }
            else
            {
                if (!m_lookInUse)   // If no pointer is in this control yet:
                {
                    m_lookLastPoint = position;                   // Save the pointer for a later move.
                    m_lookPointerID = pointerID;                  // Store the pointer using this control.
                    m_lookLastDelta.x = m_lookLastDelta.y = 0;    // These are for smoothing.
                    m_lookInUse = true;
                }
            }
            break;

        default:
            // ...
            // Handle mouse input here.
                                                // ...
            break;
        }
        break;
    }
    return;
}
```

Xx x [**XxxxxxxXxxxxxx**](https://msdn.microsoft.com/library/windows/apps/br208278) xxxxx xxx xxxxxxxx xx xxx xx xxx xxxxx xxxxxxx xxxxxxx, xxx xxxx xxxxxxxxx, xxx xxxx xxxxxxxxx, xx xxx xxxx xx xxx xxxxxx (xxx xxxx xxxxxxx), xxx **XxxxXxxxXxxxxxxxxx** xxxxxxx xxx xxxxxxx XX xxx xxx xxxxxxx xxxx xxxxx xxx xxxxx xx x xxxxxxxx xxxxxxxx xxxx xxxxxxxxxxx xx xxx xxxxxx xx xxx xxxxxx xxx xxxxx xxx xxxxx xx. Xxx xxxxxxx, xx xxx xxxxx xxxxxxxx xx xxx xxxx xxxxxxxxx, xxx **x\_xxxxXxxxxxxXX** xxxxxxxx xx xxx xx xxx xxxxxxx XX xxxx xxxxx xxx xxxxx. X Xxxxxxx "xx xxx" xxxxxxxx (**x\_xxxxXxXxx**, xx xxx xxxxxxx) xx xxxx xxx xx xxxxxxxx xxxx xxx xxxxxxx xxx xxx xxxx xxxxxxxx xxx.

Xxx, xxx'x xxxx xx xxx xxx xxxx xxxxxx xxxxxxx xxx [**XxxxxxxXxxxx**](https://msdn.microsoft.com/library/windows/apps/br208276) xxxxx xxxxxx xxxxx.

```cpp
void MoveLookController::OnPointerMoved(
    _In_ CoreWindow^ sender,
    _In_ PointerEventArgs^ args
    )
{
    PointerPoint^ point = args->CurrentPoint;
    UINT32 pointerID = point->PointerId;
    Point pointerPosition = point->Position;
    PointerPointProperties^ pointProperties = point->Properties;
    auto pointerDevice = point->PointerDevice;
    auto pointerDeviceType = pointerDevice->PointerDeviceType;

    XMFLOAT2 position = XMFLOAT2(pointerPosition.X, pointerPosition.Y);     // Convert to allow math.

    switch (m_state)
    {
    case MoveLookControllerState::Active:
        // Decide which control this pointer is operating.
        if (pointerID == m_movePointerID)     // This is the move pointer.
        {
            m_movePointerPosition = position;       // Save the current position.
        }
        else if (pointerID == m_lookPointerID)     // This is the look pointer.
        {
            // Look control
            XMFLOAT2 pointerDelta;
            pointerDelta.x = position.x - m_lookLastPoint.x;        // How far did the pointer move.
            pointerDelta.y = position.y - m_lookLastPoint.y;

            XMFLOAT2 rotationDelta;
            rotationDelta.x = pointerDelta.x * ROTATION_GAIN;       // Scale for control sensitivity.
            rotationDelta.y = pointerDelta.y * ROTATION_GAIN;
            m_lookLastPoint = position;                             // Save for the next time through.

            // Update our orientation based on the command.
            m_pitch -= rotationDelta.y;
            m_yaw   += rotationDelta.x;

            // Limit pitch to straight up or straight down.
            m_pitch = __max(-XM_PI / 2.0f, m_pitch);
            m_pitch = __min(+XM_PI / 2.0f, m_pitch);
        }
        else if (pointerID == m_firePointerID)
        {
            m_fireLastPoint = position;
        }
        else if (pointerID == m_mousePointerID)
        {
            // ...
        }
        break;
    }
}
```

Xxx **XxxxXxxxXxxxxxxxxx** xxxxxx xxx xxxxxxx XX xx xxxxxxxxx xxxxx xxx xxxxx xxxxxxxx, xxx xxxxx xxx xx xxx xxxxxxxxx xxxxxxx:

-   Xx xxx [**XxxxxxxXxxxx**](https://msdn.microsoft.com/library/windows/apps/br208276) xxxxx xxxxxxxx xx xxx xxxx xx xxxx xxxxxxxxx, xxxxxx xxx xxxxxxx xxxxxxxx xxx xxx xxxxxxxxxx.
-   Xx xxx [**XxxxxxxXxxxx**](https://msdn.microsoft.com/library/windows/apps/br208276) xxxxx xxxxxxxx xxxxxxxxx xx xxx xxxx xx xxx xxxxxx (xxxxxxx xx xxx xxxx xxxxxxxx), xxxxxxxxx xxx xxxxxx xx xxxxx xxx xxx xx xxx xxxx xxxxxxxxx xxxxxx.

Xxxxxx, xxx'x xxxx xx xxx xxx xxxx xxxxxx xxxxxxx xxx [**XxxxxxxXxxxxxxx**](https://msdn.microsoft.com/library/windows/apps/br208279) xxxxx xxxxxx xxxxx.

```cpp
void MoveLookController::OnPointerReleased(
    _In_ CoreWindow^ sender,
    _In_ PointerEventArgs^ args
    )
{
    PointerPoint^ point = args->CurrentPoint;
    UINT32 pointerID = point->PointerId;
    Point pointerPosition = point->Position;
    PointerPointProperties^ pointProperties = point->Properties;

    XMFLOAT2 position = XMFLOAT2(pointerPosition.X, pointerPosition.Y);     // Convert to allow math.
    switch (m_state)
    {
    case MoveLookControllerState::WaitForInput:
        if (m_buttonInUse && (pointerID == m_buttonPointerID))
        {
            m_buttonInUse = false;
            m_buttonPressed = true;
        }
        break;

    case MoveLookControllerState::Active:
        if (pointerID == m_movePointerID)
        {
            m_velocity = XMFLOAT3(0, 0, 0);      // Stop on release.
            m_moveInUse = false;
            m_movePointerID = 0;
        }
        else if (pointerID == m_lookPointerID)
        {
            m_lookInUse = false;
            m_lookPointerID = 0;
        }
        else if (pointerID == m_firePointerID)
        {
            m_fireInUse = false;
            m_firePointerID = 0;
        }
        else if (pointerID == m_mousePointerID)
        {
            // ...
        }
        break;
    }
}
```

Xx xxx XX xx xxx xxxxxxx xxxx xxxxx xxx [**XxxxxxxXxxxxxxx**](https://msdn.microsoft.com/library/windows/apps/br208279) xxxxx xx xxx XX xx xxx xxxxxxxxxx xxxxxxxx xxxx xxxxxxx, xxx **XxxxXxxxXxxxxxxxxx** xxxx xxx xxxxxxxx xx Y xxxxxxx xxx xxxxxx xxx xxxxxxx xxxxxxxx xxx xxxx xxxxxxxxx. Xx xx xxxx'x xxx xxx xxxxxxxx xx Y, xxx xxxxxx xxxxx xxxx xxxxxx! Xx xxx xxxx xx xxxxxxxxx xxxx xxxx xx xxxxxxx, xxxx xx xxxxx xxx xxx xxx xxxxxx xxxx xxxxxx xxxxxxxxx xxx xxxxxxxx xx Y xxxx xxxxxx xxxxx xx **Xxxxxx** xxxx xxx xxxx xxxx.

Xxxxxxxxx, xx xxx [**XxxxxxxXxxxxxxx**](https://msdn.microsoft.com/library/windows/apps/br208279) xxxxx xxxxx xx xxx xxxx xxxxxxxxx xx xxx xxxx xxxxxx, xxx **XxxxXxxxXxxxxxxxxx** xxxxxx xxx xxxxxxxx xxxxxxx XXx.

Xxxx'x xxx xxxxxx xx xxx xxxxx xxxxxx xxxxxxxx xxx xxxxxxxxxxx xx xxx xxxx xxxxxx. Xxx'x xxxx xx xx xxxxx xxx xxxxxxxx xxxxxxxx.

## Xxxxxxxxxxxx xxxxx xxx xxxxxxxx xxxxxxxx


Xxx xxxx xxxxxx xxxxxxxxxx xxxxx xxxxx xxx xxxxxxxx xxxxxxxx:

-   Xxx X, X, X, xxx X xxxx xxxx xxx xxxxxx xxxx xxxxxxx, xxxxxxxx, xxxx, xxx xxxxx, xxxxxxxxxxxx. Xxxxxxxx X xxx xxx xxxxx xxx xxxx xxx xxxx xx xxx xxxx, xxxxxxxxxxxx.
-   Xxxxxxxx xxx X xxx xxxxxx xxx xxxx.
-   Xxxxxx xxx xxxxx xxxx xxx xxxxxx xx xxxxxxx xx xxx xxxxxxxx (xxx xxxxx xxx xxx) xx xxx xxxxxx xxxx.
-   Xxxxxxxx xxx xxxx xxxxxx xxxxx x xxxxxx.

Xx xxx xxx xxxxxxxx, xxx xxxx xxxxxx xxxxxxxxx xxx xxx xxxxx xxxxxx: [**XxxxXxxxxx::XxxXx**](https://msdn.microsoft.com/library/windows/apps/br208271) xxx [**XxxxXxxxxx::XxxXxxx**](https://msdn.microsoft.com/library/windows/apps/br208270), xxxxx xxxxxx xxx xxxxx xxx xxx xxxxxxx xx x xxx, xxxxxxxxxxxx.

```cpp
window->KeyDown +=
        ref new TypedEventHandler<CoreWindow^, KeyEventArgs^>(this, &MoveLookController::OnKeyDown);

window->KeyUp +=
        ref new TypedEventHandler<CoreWindow^, KeyEventArgs^>(this, &MoveLookController::OnKeyUp);
```

Xxx xxxxx xx xxxxxxx x xxxxxx xxxxxxxxxxx xxxx xxx xxxxx xxxxxxxx, xxxx xxxxxx xx xxxx x xxxxxxx. Xxxxxxxxx, xx xxxxx'x xxx xxx xxxx xxx xxxx xxxxxxxxxx, xx xxxx xxxxx xx xxxx xxxxxxxxxx xxx xxx xxxxxx: xxx xxxxx xxxx xxxxx xxx xxxx xxx xxxx xxxxxxxx xx xxx xxxx xxxx? Xx xxxxx xxxxxxx, xxx **XxxxXxxxXxxxxxxxxx** xxxxxxxxxx xxxxxxx xxx xxxx xxxxxxxx xxxxxxxx xxx xxxxx xx xxxxx, xxx xxxxxxx xxx xxxx xxxxxxxx xxxx xxx xxxx xxxxx xxxxxx xx xxxxxxx, xx xxxxx xxxx.

```cpp
void MoveLookController::OnPointerPressed(
    _In_ CoreWindow^ /* sender */,
    _In_ PointerEventArgs^ args
    )
{
    PointerPoint^ point = args->CurrentPoint;
    uint32 pointerID = point->PointerId;
    Point pointerPosition = point->Position;
    PointerPointProperties^ pointProperties = point->Properties;
    auto pointerDevice = point->PointerDevice;
    auto pointerDeviceType = pointerDevice->PointerDeviceType;

    XMFLOAT2 position = XMFLOAT2(pointerPosition.X, pointerPosition.Y);     // convert to allow math

    switch (m_state)
    {
    case MoveLookControllerState::WaitForInput:
        if (position.x > m_buttonUpperLeft.x &&
            position.x < m_buttonLowerRight.x &&
            position.y > m_buttonUpperLeft.y &&
            position.y < m_buttonLowerRight.y)
        {
            // Wait until the button is released before setting the variable.
            m_buttonPointerID = pointerID;
            m_buttonInUse = true;

        }
        break;

    case MoveLookControllerState::Active:
        switch (pointerDeviceType)
        {
        case Windows::Devices::Input::PointerDeviceType::Touch:
            // Check to see if this pointer is in the move control.
            if (position.x > m_moveUpperLeft.x &&
                position.x < m_moveLowerRight.x &&
                position.y > m_moveUpperLeft.y &&
                position.y < m_moveLowerRight.y)
            {
                if (!m_moveInUse)         // If no pointer is in this control yet:
                {
                    // Process a DPad touch down event.
                    m_moveFirstDown = position;                 // Save the location of the initial contact.
                    m_movePointerID = pointerID;                // Store the pointer using this control.
                    m_moveInUse = true;
                }
            }
            // Check to see if this pointer is in the fire control.
            else if (position.x > m_fireUpperLeft.x &&
                position.x < m_fireLowerRight.x &&
                position.y > m_fireUpperLeft.y &&
                position.y < m_fireLowerRight.y)
            {
                if (!m_fireInUse)
                {
                    m_fireLastPoint = position;
                    m_firePointerID = pointerID;
                    m_fireInUse = true;
                    if (!m_autoFire)
                    {
                        m_firePressed = true;
                    }
                }
            }
            else
            {
                if (!m_lookInUse)   // If no pointer is in this control yet:
                {
                    m_lookLastPoint = position;                   // Save the pointer for a later move.
                    m_lookPointerID = pointerID;                  // Store the pointer using this control.
                    m_lookLastDelta.x = m_lookLastDelta.y = 0;    // These are for smoothing.
                    m_lookInUse = true;
                }
            }
            break;

        default:
            bool rightButton = pointProperties->IsRightButtonPressed;
            bool leftButton = pointProperties->IsLeftButtonPressed;

            if (!m_autoFire && (!m_mouseLeftInUse && leftButton))
            {
                m_firePressed = true;
            }

            if (!m_mouseInUse)
            {
                m_mouseInUse = true;
                m_mouseLastPoint = position;
                m_mousePointerID = pointerID;
                m_mouseLeftInUse = leftButton;
                m_mouseRightInUse = rightButton;
                m_lookLastDelta.x = m_lookLastDelta.y = 0;          // These are for smoothing.
            }
            else
            {

            }
            break;
        }

        break;
    }

    return;
}
```

Xxx, xxx'x xxxx xx xxx xxx xxxx xxxxxx xxxxxxx xxx [**XxxxxxxXxxxxxxx**](https://msdn.microsoft.com/library/windows/apps/br208279) xxxxx xxxxx.

```cpp
void MoveLookController::OnPointerReleased(
    _In_ CoreWindow^ /* sender */,
    _In_ PointerEventArgs^ args
    )
{
    PointerPoint^ point = args->CurrentPoint;
    uint32 pointerID = point->PointerId;
    Point pointerPosition = point->Position;
    PointerPointProperties^ pointProperties = point->Properties;

    XMFLOAT2 position = XMFLOAT2(pointerPosition.X, pointerPosition.Y);     // Convert to allow math.
    switch (m_state)
    {
    case MoveLookControllerState::WaitForInput:
        if (m_buttonInUse && (pointerID == m_buttonPointerID))
        {
            m_buttonInUse = false;
            m_buttonPressed = true;
        }
        break;

    case MoveLookControllerState::Active:
        if (pointerID == m_movePointerID)
        {
            m_velocity = XMFLOAT3(0, 0, 0);      // Stop on release.
            m_moveInUse = false;
            m_movePointerID = 0;
        }
        else if (pointerID == m_lookPointerID)
        {
            m_lookInUse = false;
            m_lookPointerID = 0;
        }
        else if (pointerID == m_firePointerID)
        {
            m_fireInUse = false;
            m_firePointerID = 0;
        }
        else if (pointerID == m_mousePointerID)
        {
            bool rightButton = pointProperties->IsRightButtonPressed;
            bool leftButton = pointProperties->IsLeftButtonPressed;

            m_mouseInUse = false;

            // Don't clear the mouse pointer ID so that Move events still result in Look changes.
            // m_mousePointerID = 0;
            m_mouseLeftInUse = leftButton;
            m_mouseRightInUse = rightButton;
        }
        break;
    }
}
```

Xxxx xxx xxxxxx xxxxx xxxxxxxx xxx xx xxx xxxxx xxxxxxx, xxx xxxxx xx xxxxxxxx: xxx xxxxxxx xxxx xxxxxx. Xxx, xxxxxxx xxxx xx xxxxxx xxxxxxx, xxx xxxx xxxxxxxxx xx xxx xxx xxxx xxxxx xxxxxxx xx xxxxx xxx xxxxxxx xxxx xxxxxx.

Xxx, xxx'x xxxx xx xxx xxxx xx xxxxxxx xxxxx: xxx Xxxx xxxxxxxxxx. Xx'x xxxxxxx xxxxxxxxxx xxxx xxx xxxxx xxx xxxxx xxxxxxxx, xxxxxxx xx xxxxx'x xxx xxx xxxxxxx xxxxxx.

## Xxxxxxxxxxxx Xxxx xxxxxxxxxx xxxxxxxx


Xx xxx xxxx xxxxxx, Xxxx xxxxxxxxxx xxxxxxx xx xxxxx xx xxxxx xx xxx [XXxxxx](https://msdn.microsoft.com/library/windows/desktop/hh405053) XXXx, xxxxx xxx xxx xx XXXx xxxxxxxx xx xxxxxxxx xxxxxxxxxxx xxx xxxx xxxxxxxxxxx. Xx xxx xxxx xxxxxx, xx xxx xxx Xxxx xxxxxxxxxx'x xxxx xxxxxx xxxxx xxx xxxxxx xxxxxxxx, xxx xxxxx xxxxxx xxxxx xxx xxx xxxx xxxxxxxx, xxx xxx xxxxx xxxxxxx xx xxxx. Xx xxx xxx xxxxx xxxxxx xx xxxxx xxx xxxxxx xxx xxxx.

Xxx **Xxxxxx** xxxxxx xx xxx **XxxxXxxxXxxxxxxxxx** xxxxxxxx xxxxxxxxxxx xxxxxx xx xxx xx x xxxx xxxxxxxxxx xx xxxxxxxxx, xxx xxxx xxxxxx xxx xxxxxxxxxx xxxxx.

```cpp
void MoveLookController::UpdateGameController()
{
    if (!m_isControllerConnected)
    {
        // Check for controller connection by trying to get the capabilties.
        DWORD capsResult = XInputGetCapabilities(0, XINPUT_FLAG_GAMEPAD, &m_xinputCaps);
        if (capsResult != ERROR_SUCCESS)
        {
            return;
        }
        // Device is connected.
        m_isControllerConnected = true;
        m_xinputStartButtonInUse = false;
        m_xinputTriggerInUse = false;
    }

    DWORD stateResult = XInputGetState(0, &m_xinputState);
    if (stateResult != ERROR_SUCCESS)
    {
        // Device is no longer connected.
        m_isControllerConnected = false;
    }

    switch (m_state)
    {
    case MoveLookControllerState::WaitForInput:
        if (m_xinputState.Gamepad.wButtons & XINPUT_GAMEPAD_START)
        {
            m_xinputStartButtonInUse = true;
        }
        else if (m_xinputStartButtonInUse)
        {
            // Trigger one time only on button release.
            m_xinputStartButtonInUse = false;
            m_buttonPressed = true;
        }
        break;

    case MoveLookControllerState::Active:
        if (m_xinputState.Gamepad.wButtons & XINPUT_GAMEPAD_START)
        {
            m_xinputStartButtonInUse = true;
        }
        else if (m_xinputStartButtonInUse)
        {
            // Trigger one time only on button release.
            m_xinputStartButtonInUse = false;
            m_pausePressed = true;
        }
        // Use the Right Thumb joystick on the XBox controller to control
        // the eye point position control.
        // The controller input goes from -32767 to 32767.   We will normalize
        // this from -1 to 1 and keep a dead spot in the middle to avoid drift.

        if (m_xinputState.Gamepad.sThumbLX > XINPUT_GAMEPAD_LEFT_THUMB_DEADZONE ||
            m_xinputState.Gamepad.sThumbLX < -XINPUT_GAMEPAD_LEFT_THUMB_DEADZONE)
        {
            float x = (float)m_xinputState.Gamepad.sThumbLX/32767.0f;
            m_moveCommand.x -= x / fabsf(x);
        }

        if (m_xinputState.Gamepad.sThumbLY > XINPUT_GAMEPAD_LEFT_THUMB_DEADZONE ||
            m_xinputState.Gamepad.sThumbLY < -XINPUT_GAMEPAD_LEFT_THUMB_DEADZONE)
        {
            float y = (float)m_xinputState.Gamepad.sThumbLY/32767.0f;
            m_moveCommand.y += y / fabsf(y);
        }

        // Use the Left Thumb Joystick on the XBox controller to control
        // the look at control.
        // The controller input goes from -32767 to 32767.   We will normalize
        // this from -1 to 1 and keep a dead spot in the middle to avoid drift.
        XMFLOAT2 pointerDelta;
        if (m_xinputState.Gamepad.sThumbRX > XINPUT_GAMEPAD_RIGHT_THUMB_DEADZONE ||
            m_xinputState.Gamepad.sThumbRX < -XINPUT_GAMEPAD_RIGHT_THUMB_DEADZONE)
        {
            pointerDelta.x = (float)m_xinputState.Gamepad.sThumbRX/32767.0f;
            pointerDelta.x = pointerDelta.x * pointerDelta.x * pointerDelta.x;
        }
        else
        {
            pointerDelta.x = 0.0f;
        }
        if (m_xinputState.Gamepad.sThumbRY > XINPUT_GAMEPAD_RIGHT_THUMB_DEADZONE ||
            m_xinputState.Gamepad.sThumbRY < -XINPUT_GAMEPAD_RIGHT_THUMB_DEADZONE)
        {
            pointerDelta.y = (float)m_xinputState.Gamepad.sThumbRY/32767.0f;
            pointerDelta.y = pointerDelta.y * pointerDelta.y * pointerDelta.y;
        }
        else
        {
            pointerDelta.y = 0.0f;
        }

        XMFLOAT2 rotationDelta;
        rotationDelta.x = pointerDelta.x *  0.08f;       // Scale for control sensitivity.
        rotationDelta.y = pointerDelta.y *  0.08f;

        // Update our orientation based on the command.
        m_pitch += rotationDelta.y;
        m_yaw   += rotationDelta.x;

        // Limit pitch to straight up or straight down.
        m_pitch = __max(-XM_PI / 2.0f, m_pitch);
        m_pitch = __min(+XM_PI / 2.0f, m_pitch);

        // Check the state of the A button.  This is used to indicate fire control.

        if (m_xinputState.Gamepad.bRightTrigger > XINPUT_GAMEPAD_TRIGGER_THRESHOLD)
        {
            if (!m_autoFire && !m_xinputTriggerInUse)
            {
                m_firePressed = true;
            }
            m_xinputTriggerInUse = true;
        }
        else
        {
            m_xinputTriggerInUse = false;
        }
        break;
    }
}
```

Xx xxx xxxx xxxxxxxxxx xx xx xxx **Xxxxxx** xxxxx, xxxx xxxxxx xxxxxx xx xxx xx x xxxx xxxxx xxx xxxx xxxxxx xxxxx xx x xxxxxxxx xxxxxxxxx. Xxx xxx xxxxxxxx xx xxx xxxxx xx x xxxxxxxx xxxxxxxxx xxxx xxxxxxxx xx xxxxxx xxxx xxx xxxxxx xx xxx xxxx xxxx; xxxxxxxxx, xxxxxxx xxxx xxxxxx. Xxxx xxxx xxxx xxxxxx xx xxxxxxxxx xx xxxxxxx "xxxxxxxx," xxxxx xx xxxx xxx xxxxxxxxxx xxxxx xx xxxxxx xxxxxxxxx xxxx xxx xxxxxx'x xxxxx xx xx xxxxx xx xxx xxxxx. Xx xx xxx'x xxxx xxxx xxxx xxxx, xxx xxxxxx xxx xxx xxxxxxx xxxx xxxxxxx, xx xxx xxxxxxxx xxxx xxxx xxxxxxx.

Xxx **Xxxxxx** xxxxxx xxxx xxxxxxxx xxx xxxx xxxxx xx xxx xxxxx xxxxx, xx xxx xx xxx xxxxxx xxx xxxxxxx xxx xxxxxxxxx xxx xxxxxx xx xxxxxxx, xx xxxx xx xxx xxxxxxxx xx xxx xxxxx xx xxxxxx xxxx xxxxxxx xxxx xxxx xxxxxx.

**Xxxxxx** xxxxxxxx xxx xxx xxxxx xxx xxx, xxx xxxx xxxxxx xx xxx xx xxx xxxx xxxxxxx xxx xxxxx xxxxxx xxxxxxx, xxx xxxx xxxxxx.

Xxx xxxx'x xxx xxxx xxxxxx xxxxxxxxxx x xxxx xxx xx xxxxxxx xxxxxxx. Xxxxx, xxxxxxxx xxxx x xxxx XXX xxx xxxxxxxx x xxxxx xx xxxxxxx xxxxxxx, xx xxxxxxx xxxx xxxxxxxxx xxxx xxxxxxx xxx xxxxxxx xxx xxxx xx xxx xxx xxxx xxxxxx!

## Xxxx xxxxx


Xx'xx xxxxxxxx xxxxx xxxxx xxxxxxxxx xx x XXX XxxxxxX xxxx xxxxxx xxx: xxxxx! Xxxxx xxx xxxxx xxxxxxx xxx xxxxxxxxx xx xxx xxxx, xx xxx'x xxxxxxx [xxxxxx xxxxx](tutorial--adding-sound.md)!

## Xxxxxxxx xxxxxx xxxx xxx xxxx xxxxxxx


XxxxXxxxXxxxxxxxxx.x

```cpp
//// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//// PARTICULAR PURPOSE.
////
//// Copyright (c) Microsoft Corporation. All rights reserved

#pragma once

// Uncomment to print debug tracing.
// #define MOVELOOKCONTROLLER_TRACE 1

enum class MoveLookControllerState
{
    None,
    WaitForInput,
    Active,
};

ref class MoveLookController
{
internal:
    MoveLookController();

    void Initialize(
        _In_ Windows::UI::Core::CoreWindow^ window
        );
    void SetMoveRect(
        _In_ DirectX::XMFLOAT2 upperLeft,
        _In_ DirectX::XMFLOAT2 lowerRight
        );
    void SetFireRect(
        _In_ DirectX::XMFLOAT2 upperLeft,
        _In_ DirectX::XMFLOAT2 lowerRight
        );
    void WaitForPress(
        _In_ DirectX::XMFLOAT2 UpperLeft,
        _In_ DirectX::XMFLOAT2 LowerRight
        );
    void WaitForPress();

    void Update();
    bool IsFiring();
    bool IsPressComplete();
    bool IsPauseRequested();

    DirectX::XMFLOAT3 Velocity();
    DirectX::XMFLOAT3 LookDirection();
    float Pitch();
    void  Pitch(_In_ float pitch);
    float Yaw();
    void  Yaw(_In_ float yaw);
    bool  Active();
    void  Active(_In_ bool active);

    bool AutoFire();
    void AutoFire(_In_ bool AutoFire);

protected:
    void OnPointerPressed(
        _In_ Windows::UI::Core::CoreWindow^ sender,
        _In_ Windows::UI::Core::PointerEventArgs^ args
        );
    void OnPointerMoved(
        _In_ Windows::UI::Core::CoreWindow^ sender,
        _In_ Windows::UI::Core::PointerEventArgs^ args
        );
    void OnPointerReleased(
        _In_ Windows::UI::Core::CoreWindow^ sender,
        _In_ Windows::UI::Core::PointerEventArgs^ args
        );
    void OnPointerExited(
        _In_ Windows::UI::Core::CoreWindow^ sender,
        _In_ Windows::UI::Core::PointerEventArgs^ args
        );
    void OnKeyDown(
        _In_ Windows::UI::Core::CoreWindow^ sender,
        _In_ Windows::UI::Core::KeyEventArgs^ args
        );
    void OnKeyUp(
        _In_ Windows::UI::Core::CoreWindow^ sender,
        _In_ Windows::UI::Core::KeyEventArgs^ args
        );

    void OnMouseMoved(
        _In_ Windows::Devices::Input::MouseDevice^ mouseDevice,
        _In_ Windows::Devices::Input::MouseEventArgs^ args
        );

#ifdef MOVELOOKCONTROLLER_TRACE
    void DebugTrace(const wchar_t *format, ...);
#endif

private:
    // Properties of the controller object
    MoveLookControllerState     m_state;
    DirectX::XMFLOAT3           m_velocity;             // How far we move it this frame
    float                       m_pitch;
    float                       m_yaw;                  // Orientation euler angles in radians

    // Properties of the Move control
    DirectX::XMFLOAT2           m_moveUpperLeft;        // Bounding box where this control will activate
    DirectX::XMFLOAT2           m_moveLowerRight;
    bool                        m_moveInUse;            // The move control is in use.
    uint32                      m_movePointerID;        // The id of the pointer in this control.
    DirectX::XMFLOAT2           m_moveFirstDown;        // The point where the initial contact occurred.
    DirectX::XMFLOAT2           m_movePointerPosition;  // The point where the move pointer is currently located.
    DirectX::XMFLOAT3           m_moveCommand;          // The net command from the move control.

    // Properties of the Look control
    bool                        m_lookInUse;            // The look control is in use.
    uint32                      m_lookPointerID;        // The id of the pointer in this control.
    DirectX::XMFLOAT2           m_lookLastPoint;        // The last point (from last frame)
    DirectX::XMFLOAT2           m_lookLastDelta;        // for smoothing.

    // Properties of the Fire control
    bool                        m_autoFire;
    bool                        m_firePressed;
    DirectX::XMFLOAT2           m_fireUpperLeft;        // The bounding box where this control will activate.
    DirectX::XMFLOAT2           m_fireLowerRight;
    bool                        m_fireInUse;            // The fire control is in use.
    UINT32                      m_firePointerID;        // The id of the pointer in this control.
    DirectX::XMFLOAT2           m_fireLastPoint;        // The last fire position.

    // Properties of the Mouse control. This is a combination of Look and Fire.
    bool                        m_mouseInUse;
    uint32                      m_mousePointerID;
    DirectX::XMFLOAT2           m_mouseLastPoint;
    bool                        m_mouseLeftInUse;
    bool                        m_mouseRightInUse;

    bool                        m_buttonInUse;
    uint32                      m_buttonPointerID;
    DirectX::XMFLOAT2           m_buttonUpperLeft;
    DirectX::XMFLOAT2           m_buttonLowerRight;
    bool                        m_buttonPressed;
    bool                        m_pausePressed;

    // XBox Input related members
    bool                        m_isControllerConnected;  // Do we have a controller connected?
    XINPUT_CAPABILITIES         m_xinputCaps;             // The capabilites of the controller.
    XINPUT_STATE                m_xinputState;            // The current state of the controller.
    bool                        m_xinputStartButtonInUse;
    bool                        m_xinputTriggerInUse;

    // Input states for Keyboard
    bool                        m_forward;
    bool                        m_back;                    // States for movement
    bool                        m_left;
    bool                        m_right;
    bool                        m_up;
    bool                        m_down;
    bool                        m_pause;

private:
    void     ResetState();
    void     UpdateGameController();
};
```

XxxxXxxxXxxxxxxxxx.xxx

```cpp
//// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//// PARTICULAR PURPOSE.
////
//// Copyright (c) Microsoft Corporation. All rights reserved

#include "pch.h"
#include "MoveLookController.h"
#include "DirectXSample.h"

using namespace Windows::UI::Core;
using namespace Windows::UI::Input;
using namespace Windows::UI;
using namespace Windows::Foundation;
using namespace Microsoft::WRL;
using namespace DirectX;
using namespace Windows::Devices::Input;
using namespace Windows::System;

#define ROTATION_GAIN 0.008f        // The sensitivity adjustment for the look controller.
#define MOVEMENT_GAIN 2.f           // The sensitivity adjustment for the move controller.

// A basic Move/Look Controller class such as in an FPS
// horizontal (x-z-plane) movement on left virtual joystick
// also supports WASD keyboard input
// steering and orientation via left mouse down or touch drag.

//----------------------------------------------------------------------

MoveLookController::MoveLookController():
    m_autoFire(true),
    m_isControllerConnected(false)
{
}

//----------------------------------------------------------------------
// Set up the controls supported by this controller.

void MoveLookController::Initialize(
    _In_ CoreWindow^ window
    )
{
    window->PointerPressed +=
        ref new TypedEventHandler<CoreWindow^, PointerEventArgs^>(this, &MoveLookController::OnPointerPressed);

    window->PointerMoved +=
        ref new TypedEventHandler<CoreWindow^, PointerEventArgs^>(this, &MoveLookController::OnPointerMoved);

    window->PointerReleased +=
        ref new TypedEventHandler<CoreWindow^, PointerEventArgs^>(this, &MoveLookController::OnPointerReleased);

    window->PointerExited +=
        ref new TypedEventHandler<CoreWindow^, PointerEventArgs^>(this, &MoveLookController::OnPointerExited);

    window->KeyDown +=
        ref new TypedEventHandler<CoreWindow^, KeyEventArgs^>(this, &MoveLookController::OnKeyDown);

    window->KeyUp +=
        ref new TypedEventHandler<CoreWindow^, KeyEventArgs^>(this, &MoveLookController::OnKeyUp);

    // A separate handler for mouse only relative mouse movement events.
    Windows::Devices::Input::MouseDevice::GetForCurrentView()->MouseMoved +=
        ref new TypedEventHandler<MouseDevice^, MouseEventArgs^>(this, &MoveLookController::OnMouseMoved);

    ResetState();
    m_state = MoveLookControllerState::None;

    m_pitch = 0.0f;
    m_yaw   = 0.0f;
}

//----------------------------------------------------------------------

bool MoveLookController::IsPauseRequested()
{
    switch (m_state)
    {
    case MoveLookControllerState::Active:
        UpdateGameController();
        if (m_pausePressed)
        {

            m_pausePressed = false;
            return true;
        }
        else
        {
            return false;
        }
    }
    return false;
}

//----------------------------------------------------------------------

bool MoveLookController::IsFiring()
{
    if (m_state == MoveLookControllerState::Active)
    {
        if (m_autoFire)
        {
            return (m_fireInUse || (m_mouseInUse && m_mouseLeftInUse) || m_xinputTriggerInUse);
        }
        else
        {
            if (m_firePressed)
            {
                m_firePressed = false;
                return true;
            }
        }
    }
    return false;
}

//----------------------------------------------------------------------

bool MoveLookController::IsPressComplete()
{
    switch (m_state)
    {
    case MoveLookControllerState::WaitForInput:
        UpdateGameController();
        if (m_buttonPressed)
        {

            m_buttonPressed = false;
            return true;
        }
        else
        {
            return false;
        }
        break;
    }

    return false;
}

//----------------------------------------------------------------------

void MoveLookController::OnPointerPressed(
    _In_ CoreWindow^ /* sender */,
    _In_ PointerEventArgs^ args
    )
{
    PointerPoint^ point = args->CurrentPoint;
    uint32 pointerID = point->PointerId;
    Point pointerPosition = point->Position;
    PointerPointProperties^ pointProperties = point->Properties;
    auto pointerDevice = point->PointerDevice;
    auto pointerDeviceType = pointerDevice->PointerDeviceType;

    XMFLOAT2 position = XMFLOAT2(pointerPosition.X, pointerPosition.Y);     // Convert to allow math.

    switch (m_state)
    {
    case MoveLookControllerState::WaitForInput:
        if (position.x > m_buttonUpperLeft.x &&
            position.x < m_buttonLowerRight.x &&
            position.y > m_buttonUpperLeft.y &&
            position.y < m_buttonLowerRight.y)
        {
            // Wait until button released before setting variable.
            m_buttonPointerID = pointerID;
            m_buttonInUse = true;

        }
        break;

    case MoveLookControllerState::Active:
        switch (pointerDeviceType)
        {
        case Windows::Devices::Input::PointerDeviceType::Touch:
            // Check to see if this pointer is in the move control.
            if (position.x > m_moveUpperLeft.x &&
                position.x < m_moveLowerRight.x &&
                position.y > m_moveUpperLeft.y &&
                position.y < m_moveLowerRight.y)
            {
                if (!m_moveInUse)         // If no pointer is in this control yet:
                {
                    // Process a DPad touch down event.
                    m_moveFirstDown = position;                 // Save the location of the initial contact.
                    m_movePointerID = pointerID;                // Store the pointer using this control.
                    m_moveInUse = true;
                }
            }
            // Check to see if this pointer is in the fire control.
            else if (position.x > m_fireUpperLeft.x &&
                position.x < m_fireLowerRight.x &&
                position.y > m_fireUpperLeft.y &&
                position.y < m_fireLowerRight.y)
            {
                if (!m_fireInUse)
                {
                    m_fireLastPoint = position;
                    m_firePointerID = pointerID;
                    m_fireInUse = true;
                    if (!m_autoFire)
                    {
                        m_firePressed = true;
                    }
                }
            }
            else
            {
                if (!m_lookInUse)   // If no pointer is in this control yet:
                {
                    m_lookLastPoint = position;                   // Save the point for a later move.
                    m_lookPointerID = pointerID;                  // Store the pointer using this control.
                    m_lookLastDelta.x = m_lookLastDelta.y = 0;    // These are for smoothing.
                    m_lookInUse = true;
                }
            }
            break;

        default:
            bool rightButton = pointProperties->IsRightButtonPressed;
            bool leftButton = pointProperties->IsLeftButtonPressed;

            if (!m_autoFire && (!m_mouseLeftInUse && leftButton))
            {
                m_firePressed = true;
            }

            if (!m_mouseInUse)
            {
                m_mouseInUse = true;
                m_mouseLastPoint = position;
                m_mousePointerID = pointerID;
                m_mouseLeftInUse = leftButton;
                m_mouseRightInUse = rightButton;
                m_lookLastDelta.x = m_lookLastDelta.y = 0;          // These are for smoothing.
            }
            else
            {

            }
            break;
        }

        break;
    }

    return;
}

//----------------------------------------------------------------------

void MoveLookController::OnPointerMoved(
    _In_ CoreWindow^ /* sender */,
    _In_ PointerEventArgs^ args
    )
{
    PointerPoint^ point = args->CurrentPoint;
    uint32 pointerID = point->PointerId;
    Point pointerPosition = point->Position;
    PointerPointProperties^ pointProperties = point->Properties;
    auto pointerDevice = point->PointerDevice;

    XMFLOAT2 position = XMFLOAT2(pointerPosition.X, pointerPosition.Y);     // Convert to allow math.

    switch (m_state)
    {
    case MoveLookControllerState::Active:
        // Decide which control this pointer is operating.
        if (pointerID == m_movePointerID)     // This is the move pointer.
        {
            m_movePointerPosition = position;       // Save the current position.
        }
        else if (pointerID == m_lookPointerID)     // This is the look pointer.
        {
            // Look control
            XMFLOAT2 pointerDelta;
            pointerDelta.x = position.x - m_lookLastPoint.x;        // How far did the pointer move?
            pointerDelta.y = position.y - m_lookLastPoint.y;

            XMFLOAT2 rotationDelta;
            rotationDelta.x = pointerDelta.x * ROTATION_GAIN;       // Scale for control sensitivity.
            rotationDelta.y = pointerDelta.y * ROTATION_GAIN;
            m_lookLastPoint = position;                             // Save for the next time through.

            // Update our orientation based on the command.
            m_pitch -= rotationDelta.y;
            m_yaw   += rotationDelta.x;

            // Limit pitch to straight up or straight down.
            float limit = XM_PI / 2.0f - 0.01f;
            m_pitch = __max(-limit, m_pitch);
            m_pitch = __min(+limit, m_pitch);

            // Keep longitude in the same range by wrapping.
            if (m_yaw >  XM_PI)
            {
                m_yaw -= XM_PI * 2.0f;
            }
            else if (m_yaw < -XM_PI)
            {
                m_yaw += XM_PI * 2.0f;
            }
        }
        else if (pointerID == m_firePointerID)
        {
            m_fireLastPoint = position;
        }
        else if (pointerID == m_mousePointerID)
        {
            m_mouseLeftInUse  = pointProperties->IsLeftButtonPressed;
            m_mouseRightInUse = pointProperties->IsRightButtonPressed;;
            m_mouseLastPoint = position;                            // save for next time through

            // Handle mouse movement via a separate relative mouse movement handler (OnMouseMoved).
        }
        break;
    }
}

//----------------------------------------------------------------------

void MoveLookController::OnMouseMoved(
    _In_ MouseDevice^ /* mouseDevice */,
    _In_ MouseEventArgs^ args
    )
{
    // Handle Mouse Input via dedicated relative movement handler.

    switch (m_state)
    {
    case MoveLookControllerState::Active:
        XMFLOAT2 mouseDelta;
        mouseDelta.x = static_cast<float>(args->MouseDelta.X);
        mouseDelta.y = static_cast<float>(args->MouseDelta.Y);

        XMFLOAT2 rotationDelta;
        rotationDelta.x  = mouseDelta.x * ROTATION_GAIN;   // Scale for control sensitivity.
        rotationDelta.y  = mouseDelta.y * ROTATION_GAIN;

        // Update our orientation based on the command.
        m_pitch -= rotationDelta.y;
        m_yaw   += rotationDelta.x;

        // Limit pitch to straight up or straight down.
        float limit = XM_PI / 2.0f - 0.01f;
        m_pitch = __max(-limit, m_pitch);
        m_pitch = __min(+limit, m_pitch);

        // Keep longitude in same range by wrapping.
        if (m_yaw >  XM_PI)
        {
            m_yaw -= XM_PI * 2.0f;
        }
        else if (m_yaw < -XM_PI)
        {
            m_yaw += XM_PI * 2.0f;
        }
        break;
    }
}

//----------------------------------------------------------------------

void MoveLookController::OnPointerReleased(
    _In_ CoreWindow^ /* sender */,
    _In_ PointerEventArgs^ args
    )
{
    PointerPoint^ point = args->CurrentPoint;
    uint32 pointerID = point->PointerId;
    Point pointerPosition = point->Position;
    PointerPointProperties^ pointProperties = point->Properties;

    XMFLOAT2 position = XMFLOAT2(pointerPosition.X, pointerPosition.Y);     // Convert to allow math.
    switch (m_state)
    {
    case MoveLookControllerState::WaitForInput:
        if (m_buttonInUse && (pointerID == m_buttonPointerID))
        {
            m_buttonInUse = false;
            m_buttonPressed = true;
        }
        break;

    case MoveLookControllerState::Active:
        if (pointerID == m_movePointerID)
        {
            m_velocity = XMFLOAT3(0, 0, 0);      // Stop on release.
            m_moveInUse = false;
            m_movePointerID = 0;
        }
        else if (pointerID == m_lookPointerID)
        {
            m_lookInUse = false;
            m_lookPointerID = 0;
        }
        else if (pointerID == m_firePointerID)
        {
            m_fireInUse = false;
            m_firePointerID = 0;
        }
        else if (pointerID == m_mousePointerID)
        {
            bool rightButton = pointProperties->IsRightButtonPressed;
            bool leftButton = pointProperties->IsLeftButtonPressed;

            m_mouseInUse = false;

            // Don't clear the mouse pointer ID so that Move events still result in Look changes.
            // m_mousePointerID = 0;
            m_mouseLeftInUse = leftButton;
            m_mouseRightInUse = rightButton;
        }
        break;
    }
}

//----------------------------------------------------------------------

void MoveLookController::OnPointerExited(
    _In_ CoreWindow^ /* sender */,
    _In_ PointerEventArgs^ args
    )
{
    PointerPoint^ point = args->CurrentPoint;
    uint32 pointerID = point->PointerId;
    Point pointerPosition = point->Position;
    PointerPointProperties^ pointProperties = point->Properties;

    XMFLOAT2 position  = XMFLOAT2(pointerPosition.X, pointerPosition.Y);        // Convert to allow math.

    switch (m_state)
    {
    case MoveLookControllerState::WaitForInput:
        if (m_buttonInUse && (pointerID == m_buttonPointerID))
        {
            m_buttonInUse = false;
            m_buttonPressed = false;
        }
        break;

    case MoveLookControllerState::Active:
        if (pointerID == m_movePointerID)
        {
            m_velocity = XMFLOAT3(0, 0, 0);      // Stop on release.
            m_moveInUse = false;
            m_movePointerID = 0;
        }
        else if (pointerID == m_lookPointerID)
        {
            m_lookInUse = false;
            m_lookPointerID = 0;
        }
        else if (pointerID == m_firePointerID)
        {
            m_fireInUse = false;
            m_firePointerID = 0;
        }
        else if (pointerID == m_mousePointerID)
        {
            m_mouseInUse = false;
            m_mousePointerID = 0;
            m_mouseLeftInUse = false;
            m_mouseRightInUse = false;
        }
        break;
    }
}

//----------------------------------------------------------------------

void MoveLookController::OnKeyDown(
    _In_ CoreWindow^ /* sender */,
    _In_ KeyEventArgs^ args
    )
{
    Windows::System::VirtualKey Key;
    Key = args->VirtualKey;

    // Figure out the command from the keyboard.
    if (Key == VirtualKey::W)       // forward
        m_forward = true;
    if (Key == VirtualKey::S)       // back
        m_back = true;
    if (Key == VirtualKey::A)       // left
        m_left = true;
    if (Key == VirtualKey::D)       // right
        m_right = true;
    if (Key == VirtualKey::Space)   // up
        m_up = true;
    if (Key == VirtualKey::X)       // down
        m_down = true;
    if (Key == VirtualKey::P)       // Pause
        m_pause = true;
}

//----------------------------------------------------------------------

void MoveLookController::OnKeyUp(
    _In_ CoreWindow^ /* sender */,
    _In_ KeyEventArgs^ args
    )
{
    Windows::System::VirtualKey Key;
    Key = args->VirtualKey;

    // Figure out the command from the keyboard.
    if (Key == VirtualKey::W)       // Forward
        m_forward = false;
    if (Key == VirtualKey::S)       // Back
        m_back = false;
    if (Key == VirtualKey::A)       // Left
        m_left = false;
    if (Key == VirtualKey::D)       // Right
        m_right = false;
    if (Key == VirtualKey::Space)   // Up
        m_up = false;
    if (Key == VirtualKey::X)       // Down
        m_down = false;
    if (Key == VirtualKey::P)
    {
        if (m_pause)
        {
            // Trigger pause only one time on button release.
            m_pausePressed = true;
            m_pause = false;
        }
    }
}

//----------------------------------------------------------------------

void MoveLookController::ResetState()
{
    // Reset the state of the controller.
    // Disable any active pointer IDs to stop all interaction.
    m_buttonPressed = false;
    m_pausePressed = false;
    m_buttonInUse = false;
    m_moveInUse = false;
    m_lookInUse = false;
    m_fireInUse = false;
    m_mouseInUse = false;
    m_mouseLeftInUse = false;
    m_mouseRightInUse = false;
    m_movePointerID = 0;
    m_lookPointerID = 0;
    m_firePointerID = 0;
    m_mousePointerID = 0;
    m_velocity = XMFLOAT3(0.0f, 0.0f, 0.0f);

    m_xinputStartButtonInUse = false;
    m_xinputTriggerInUse = false;

    m_moveCommand = XMFLOAT3(0.0f, 0.0f, 0.0f);
    m_forward = false;
    m_back = false;
    m_left = false;
    m_right = false;
    m_up = false;
    m_down = false;
    m_pause = false;
}

//----------------------------------------------------------------------

void MoveLookController::SetMoveRect (
    _In_ XMFLOAT2 upperLeft,
    _In_ XMFLOAT2 lowerRight
    )
{
    m_moveUpperLeft  = upperLeft;
    m_moveLowerRight = lowerRight;
}

//----------------------------------------------------------------------

void MoveLookController::SetFireRect (
    _In_ XMFLOAT2 upperLeft,
    _In_ XMFLOAT2 lowerRight
    )
{
    m_fireUpperLeft  = upperLeft;
    m_fireLowerRight = lowerRight;
}

//----------------------------------------------------------------------

void MoveLookController::WaitForPress(
    _In_ XMFLOAT2 upperLeft,
    _In_ XMFLOAT2 lowerRight
    )
{

    ResetState();
    m_state = MoveLookControllerState::WaitForInput;
    m_buttonUpperLeft  = upperLeft;
    m_buttonLowerRight = lowerRight;

    // Turn on the mouse cursor.
    CoreWindow::GetForCurrentThread()->PointerCursor = ref new CoreCursor(CoreCursorType::Arrow, 0);
}

//----------------------------------------------------------------------

void MoveLookController::WaitForPress()
{
    ResetState();
    m_state = MoveLookControllerState::WaitForInput;
    m_buttonUpperLeft.x = 0.0f;
    m_buttonUpperLeft.y = 0.0f;
    m_buttonLowerRight.x = 0.0f;
    m_buttonLowerRight.y = 0.0f;

    // Turn on the mouse cursor.
    CoreWindow::GetForCurrentThread()->PointerCursor = ref new CoreCursor(CoreCursorType::Arrow, 0);
}

//----------------------------------------------------------------------

XMFLOAT3 MoveLookController::Velocity()
{
    return m_velocity;
}

//----------------------------------------------------------------------

XMFLOAT3 MoveLookController::LookDirection()
{
    XMFLOAT3 lookDirection;

    float r = cosf(m_pitch);              // In the plane
    lookDirection.y = sinf(m_pitch);      // Vertical
    lookDirection.z = r * cosf(m_yaw);    // Fwd-back
    lookDirection.x = r * sinf(m_yaw);    // Left-right

    return lookDirection;
}

//----------------------------------------------------------------------

float MoveLookController::Pitch()
{
    return m_pitch;
}

//----------------------------------------------------------------------

void MoveLookController::Pitch(_In_ float pitch)
{
    m_pitch = pitch;
}

//----------------------------------------------------------------------

float MoveLookController::Yaw()
{
    return m_yaw;
}

//----------------------------------------------------------------------

void MoveLookController::Yaw(_In_ float yaw)
{
    m_yaw = yaw;
}

//----------------------------------------------------------------------

void MoveLookController::Active(_In_ bool active)
{
    ResetState();

    if (active)
    {
        m_state = MoveLookControllerState::Active;
        // Turn the mouse cursor off (hidden).
        CoreWindow::GetForCurrentThread()->PointerCursor = nullptr;
    }
    else
    {
        m_state = MoveLookControllerState::None;
        // Turn the mouse cursor on.
        auto window = CoreWindow::GetForCurrentThread();
        if (window)
        {
            // Protect case where there isn't a window associated with the current thread.
            // This happens on initialization.
            window->PointerCursor = ref new CoreCursor(CoreCursorType::Arrow, 0);
        }
    }
}

//----------------------------------------------------------------------

bool MoveLookController::Active()
{
    if (m_state == MoveLookControllerState::Active)
    {
        return true;
    }
    else
    {
        return false;
    }
}

//----------------------------------------------------------------------

void MoveLookController::AutoFire(_In_ bool autoFire)
{
    m_autoFire = autoFire;
}

//----------------------------------------------------------------------

bool MoveLookController::AutoFire()
{
    return m_autoFire;
}

//----------------------------------------------------------------------

void MoveLookController::Update()
{
    UpdateGameController();

    if (m_moveInUse)
    {
        // Move control.
        XMFLOAT2 pointerDelta;

        pointerDelta.x = m_movePointerPosition.x - m_moveFirstDown.x;
        pointerDelta.y = m_movePointerPosition.y - m_moveFirstDown.y;

        // Figure out the command from the virtual joystick.
        XMFLOAT3 commandDirection = XMFLOAT3(0.0f, 0.0f, 0.0f);
        if (fabsf(pointerDelta.x) > 16.0f)         // leave 32 pixel-wide dead spot for being still
            m_moveCommand.x -= pointerDelta.x/fabsf(pointerDelta.x);

        if (fabsf(pointerDelta.y) > 16.0f)
            m_moveCommand.y -= pointerDelta.y/fabsf(pointerDelta.y);
    }

    // Poll our state bits set by the keyboard input events.
    if (m_forward)
    {
        m_moveCommand.y += 1.0f;
    }
    if (m_back)
    {
        m_moveCommand.y -= 1.0f;
    }
    if (m_left)
    {
        m_moveCommand.x += 1.0f;
    }
    if (m_right)
    {
        m_moveCommand.x -= 1.0f;
    }
    if (m_up)
    {
        m_moveCommand.z += 1.0f;
    }
    if (m_down)
    {
        m_moveCommand.z -= 1.0f;
    }

    // Make sure that 45 deg cases are not faster.
    if (fabsf(m_moveCommand.x) > 0.1f ||
        fabsf(m_moveCommand.y) > 0.1f ||
        fabsf(m_moveCommand.z) > 0.1f)
    {
        XMStoreFloat3(&m_moveCommand, XMVector3Normalize(XMLoadFloat3(&m_moveCommand)));
    }

    // Rotate command to align with our direction (world coordinates).
    XMFLOAT3 wCommand;
    wCommand.x =  m_moveCommand.x * cosf(m_yaw) - m_moveCommand.y * sinf(m_yaw);
    wCommand.y =  m_moveCommand.x * sinf(m_yaw) + m_moveCommand.y * cosf(m_yaw);
    wCommand.z =  m_moveCommand.z;

    // Scale for sensitivity adjustment.
    // Our velocity is based on the command, y is up.
    m_velocity.x = -wCommand.x * MOVEMENT_GAIN;
    m_velocity.z =  wCommand.y * MOVEMENT_GAIN;
    m_velocity.y =  wCommand.z * MOVEMENT_GAIN;

    // Clear the movement input accumulator for use during next frame.
    m_moveCommand = XMFLOAT3(0.0f, 0.0f, 0.0f);
}

//----------------------------------------------------------------------

void MoveLookController::UpdateGameController()
{
    if (!m_isControllerConnected)
    {
        // Check for controller connection by trying to get the capabilties.
        DWORD capsResult = XInputGetCapabilities(0, XINPUT_FLAG_GAMEPAD, &m_xinputCaps);
        if (capsResult != ERROR_SUCCESS)
        {
            return;
        }
        // The device is connected.
        m_isControllerConnected = true;
        m_xinputStartButtonInUse = false;
        m_xinputTriggerInUse = false;
    }

    DWORD stateResult = XInputGetState(0, &m_xinputState);
    if (stateResult != ERROR_SUCCESS)
    {
        // The device is no longer connected.
        m_isControllerConnected = false;
    }

    switch (m_state)
    {
    case MoveLookControllerState::WaitForInput:
        if (m_xinputState.Gamepad.wButtons & XINPUT_GAMEPAD_START)
        {
            m_xinputStartButtonInUse = true;
        }
        else if (m_xinputStartButtonInUse)
        {
            // Trigger one time only on button release.
            m_xinputStartButtonInUse = false;
            m_buttonPressed = true;
        }
        break;

    case MoveLookControllerState::Active:
        if (m_xinputState.Gamepad.wButtons & XINPUT_GAMEPAD_START)
        {
            m_xinputStartButtonInUse = true;
        }
        else if (m_xinputStartButtonInUse)
        {
            // Trigger one time only on button release.
            m_xinputStartButtonInUse = false;
            m_pausePressed = true;
        }
        // Use the Right Thumb joystick on the XBox controller to control
        // the eye point position control.
        // The controller input goes from -32767 to 32767.   We will normalize
        // this from -1 to 1 and keep a dead spot in the middle to avoid drift.

        if (m_xinputState.Gamepad.sThumbLX > XINPUT_GAMEPAD_LEFT_THUMB_DEADZONE ||
            m_xinputState.Gamepad.sThumbLX < -XINPUT_GAMEPAD_LEFT_THUMB_DEADZONE)
        {
            float x = (float)m_xinputState.Gamepad.sThumbLX/32767.0f;
            m_moveCommand.x -= x / fabsf(x);
        }

        if (m_xinputState.Gamepad.sThumbLY > XINPUT_GAMEPAD_LEFT_THUMB_DEADZONE ||
            m_xinputState.Gamepad.sThumbLY < -XINPUT_GAMEPAD_LEFT_THUMB_DEADZONE)
        {
            float y = (float)m_xinputState.Gamepad.sThumbLY/32767.0f;
            m_moveCommand.y += y / fabsf(y);
        }

        // Use the Left Thumb Joystick on the XBox controller to control
        // the look at control.
        // The controller input goes from -32767 to 32767.   We will normalize
        // this from -1 to 1 and keep a dead spot in the middle to avoid drift.
        XMFLOAT2 pointerDelta;
        if (m_xinputState.Gamepad.sThumbRX > XINPUT_GAMEPAD_RIGHT_THUMB_DEADZONE ||
            m_xinputState.Gamepad.sThumbRX < -XINPUT_GAMEPAD_RIGHT_THUMB_DEADZONE)
        {
            pointerDelta.x = (float)m_xinputState.Gamepad.sThumbRX/32767.0f;
            pointerDelta.x = pointerDelta.x * pointerDelta.x * pointerDelta.x;
        }
        else
        {
            pointerDelta.x = 0.0f;
        }
        if (m_xinputState.Gamepad.sThumbRY > XINPUT_GAMEPAD_RIGHT_THUMB_DEADZONE ||
            m_xinputState.Gamepad.sThumbRY < -XINPUT_GAMEPAD_RIGHT_THUMB_DEADZONE)
        {
            pointerDelta.y = (float)m_xinputState.Gamepad.sThumbRY/32767.0f;
            pointerDelta.y = pointerDelta.y * pointerDelta.y * pointerDelta.y;
        }
        else
        {
            pointerDelta.y = 0.0f;
        }

        XMFLOAT2 rotationDelta;
        rotationDelta.x = pointerDelta.x *  0.08f;       // scale for control sensitivity
        rotationDelta.y = pointerDelta.y *  0.08f;

        // Update our orientation based on the command.
        m_pitch += rotationDelta.y;
        m_yaw   += rotationDelta.x;

        // Limit pitch to straight up or straight down.
        m_pitch = __max(-XM_PI / 2.0f, m_pitch);
        m_pitch = __min(+XM_PI / 2.0f, m_pitch);

        // Check the state of the A button.  This is used to indicate fire control.

        if (m_xinputState.Gamepad.bRightTrigger > XINPUT_GAMEPAD_TRIGGER_THRESHOLD)
        {
            if (!m_autoFire && !m_xinputTriggerInUse)
            {
                m_firePressed = true;
            }
            m_xinputTriggerInUse = true;
        }
        else
        {
            m_xinputTriggerInUse = false;
        }
        break;
    }
}
```

> **Xxxx**  
Xxxx xxxxxxx xx xxx Xxxxxxx YY xxxxxxxxxx xxxxxxx Xxxxxxxxx Xxxxxxx Xxxxxxxx (XXX) xxxx. Xx xxx’xx xxxxxxxxxx xxx Xxxxxxx Y.x xx Xxxxxxx Xxxxx Y.x, xxx xxx [xxxxxxxx xxxxxxxxxxxxx](http://go.microsoft.com/fwlink/p/?linkid=619132).

 

## Xxxxxxx xxxxxx


[Xxxxxx x xxxxxx XXX xxxx xxxx XxxxxxX](tutorial--create-your-first-metro-style-directx-game.md)

 

 




<!--HONumber=Mar16_HO1-->
