#Android と iOS 開発者向けの Windows アプリの概念マッピング

このリソースには、Android や iOS のスキルとコードを持つ開発者が Windows 10 とユニバーサル Windows プラットフォーム (UWP) に移行する場合に、それら 3 つのプラットフォーム間でプラットフォームの機能と知識を関連付けるために必要なすべての情報が含まれています。

[iOS から UWP への移行](ios-to-uwp-root.md) の移植に関するコンテンツもご覧ください。

## ユーザー インターフェイス (UI)

|  **一般的な概念** | **Android** | **iOS** | **Windows 10 UWP** |
|  ------ | ------ | ------ | ------ |
|  **デザイン言語。** プラットフォーム上のアプリの外観と動作方法を規定する規則のセット。 | **Android のマテリアル デザイン** ガイドラインに、Android の設計者や開発者が従う視覚言語が示されています。 | **ヒューマン インターフェイス ガイドライン**に、iOS の設計者や開発者向けのアドバイスが示されています。 | [
							「**UWP アプリのデザイン**](https://dev.windows.com/design)」で、すべての Windows 10 デバイスで優れた外観を持つアプリを作成する方法について説明しています。 ユーザー インターフェイス (UI) デザインの基本、レスポンシブ デザイン テクニック、詳細なガイドラインの完全な一覧が示されています。<br/> |
|  **ユーザー インターフェイス マークアップ言語。** UI とそのコンポーネントをレンダリングし、記述するマークアップ言語。 プラットフォームごとに、ビジュアル編集とマークアップ編集のためのエディターが提供されています。<br/> | **XML レイアウト**。**Android Studio** または **Eclipse** を使って編集します。 | **XIB** と**ストーリーボード**。Xcode 内の **Interface Builder** を使って編集します。 | **[XAML](https://msdn.microsoft.com/library/windows/apps/xaml/mt185595.aspx)**。**[Microsoft Visual Studio](https://www.visualstudio.com/)** と **[Blend for Visual Studio](https://msdn.microsoft.com/library/jj171012.aspx)** を使って編集します。<br/><br/>[XAML プラットフォーム](https://msdn.microsoft.com/library/windows/apps/xaml/mt228259.aspx)<br/><br/>[XAML を使った UI の作成](https://msdn.microsoft.com/library/windows/apps/xaml/mt228349.aspx)<br/><br/>[XAML を使ったレイアウトの定義](https://msdn.microsoft.com/library/windows/apps/xaml/mt228350.aspx) |
|  **組み込みのユーザー インターフェイス コントロール。** ボタン、リスト コントロール、テキスト コントロールなど、プラットフォームで提供される、再利用可能な UI 要素。 | ウィジェット、レイアウト、テキスト フィールド、コンテナー、日付/時刻コントロール、専門的なコントロールとして参照される、作成済みの**ビュー**と**ビュー グループ**のクラス。 | Xcode オブジェクトのライブラリにあり、UIKit ユーザー インターフェイス カタログに掲載された**ビュー**と**コントロール**。 ビューには、イメージ ビュー、ピッカー ビュー、スクロール ビューが含まれます。 コントロールには、ボタン、日付選択コントロール、テキスト フィールドが含まれます。 | XAML プラットフォームでは、ボタン、リスト コントロール、パネル、テキスト コントロール、コマンド バー、ファイル ピッカー、メディア、インク入力など、さまざまな**ビルトイン コントロール**が提供されます。<br/><br/>[コントロールの追加とイベントの処理](https://msdn.microsoft.com/library/windows/apps/xaml/mt228345.aspx) |
|  **コントロール イベントの処理。** UI コントロール内でイベントがトリガーされるときに実行されるロジックを定義します。 | XML またはプログラムで**イベント ハンドラー**と**イベント リスナー**を追加します。 | コントロールから**ターゲット**へ**操作**メッセージが送信されます。 | XAML ページに接続されている**コード ビハインド ファイル**に、XAML コントロールのイベントを処理するメソッドを定義できます。 **イベント ハンドラー**は常に、コードで記述します。 ただし、XAML マークアップまたはコードでそれらのハンドラーをイベントにフックすることができます。<br/><br/>[コントロールの追加とイベントの処理](https://msdn.microsoft.com/library/windows/apps/xaml/mt228345.aspx)<br/><br/>[イベントとルーティング イベントの概要](https://msdn.microsoft.com/library/windows/apps/xaml/mt185584.aspx) |
|  **データ バインディング。** アプリの UI でデータを表示し、必要に応じてそのデータと同じ状態を保つことができるソフトウェアの設計パターンです。  | **データ バインディング ライブラリ**が提供されています。ただし、まだベータ版です。 | iOS では、組み込みのバインディング システムは存在しません。 サード パーティのライブラリを使うか追加コードを記述すると、**キー値監視**を作成してデータ バインディングを実行できます。 コントロールは、データを取得するためにデリゲート/コールバックの方法を使います。 | UWP プラットフォームが**データ バインディング**を処理します。 **
            [{x:Bind}](https://msdn.microsoft.com/library/windows/apps/mt204783.aspx)** マークアップ拡張を使ってバインディングのパフォーマンスを向上させるか、**[{Binding}](https://msdn.microsoft.com/library/windows/apps/mt204782.aspx)** を使ってより多くの機能を利用できます。 その後は、プラットフォームで**一方向バインディング**を使ってデータ ソースからの値を UI に表示するか、**双方向バインディング**で値の監視も行い、値が変わったら UI を更新するか、バインディングの構成方法を選ぶだけです。<br/><br/>[データ バインディング](https://msdn.microsoft.com/library/windows/apps/mt210947.aspx) |
|  **UI オートメーション。** プログラムによる UI 要素へのアクセスで、アプリをアクセシビリティ対応にして支援技術製品を利用できるようにして、自動テスト スクリプトで UI を操作できるようにします。 | **テキストのラベル**、**contentDescription**、**ヒント**の値を使って、オートメーションで UI 要素が見つかるようにします。 Android Studio で **UI Automator** と **Espresso** テスト フレームワークを使って UI のテストを作成できます。 | **Automation インストルメント**で、**アクセシビリティ**設定や**要素階層**内の要素の位置を使って要素を識別する、自動化された UI テスト スクリプトを記述できます。 | **
            [UI オートメーション](https://msdn.microsoft.com/library/windows/apps/ee684076.aspx)**を使って、UWP の組み込みの UI 要素にプログラムから既定でアクセスできます。<br/>**[カスタム オートメーション ピア](https://msdn.microsoft.com/library/windows/apps/mt297667.aspx)**で、独自のカスタム UI クラスのオートメーション サポートを提供できます。 Visual Studio の**[コード化された UI テスト プロジェクト](https://msdn.microsoft.com/library/dd286726.aspx#VerifyingCodeUsingCUITCreate)**で、UI を使ってアプリケーション全体を自動的にテストするか、UI を単独でテストできます。 |
|  **コントロールの外観の変更。** サイズ、色、その他の属性を編集します。 | コントロールには**プロパティ**があり、デザイナー ツールを使って XML マークアップまたはプログラムで編集できます。 | コントロールには**属性**があり、**属性インスペクター**を使って Interface Builder またはプログラムで編集できます。 | Visual Studio と Blend for Visual Studio を使って、XAML マークアップまたはプログラムでコントロールの**プロパティ**を編集できます。<br/><br/>[コントロールの追加とイベントの処理](https://msdn.microsoft.com/library/windows/apps/xaml/mt228345.aspx) |
|  **再利用可能な視覚スタイル。** 視覚的な変更を再利用可能な形式でいくつかのコントロールに適用します。 | **XML スタイル**は 1 つまたは複数のコントロールに適用されるプロパティのセットです。 | iOS では、既定では再利用可能な視覚スタイルをサポートしていませんが、UIAppearance プロトコルを使って複数のコントロールで共通の属性を共有できます。 | 再利用可能な**[スタイル](https://msdn.microsoft.com/library/windows/apps/xaml/windows.ui.xaml.style.aspx)**を作成して複数のコントロールに適用したり、簡単に再利用できるように **[ResourceDictionary](https://msdn.microsoft.com/library/windows/apps/xaml/windows.ui.xaml.resourcedictionary.aspx)** に格納したりできます。<br/><br/>[クイック スタート: コントロールのスタイル](https://msdn.microsoft.com/library/windows/apps/xaml/hh465381.aspx) |
|  **コントロールの視覚的構造の編集。** チェックボックスの下にあるチェックボックスのテキストの移動など、プロパティまたは属性を変更する以外の、コントロールの視覚的構造をカスタマイズします。 | Android では、コントロールの視覚的構造を編集する簡単な方法は存在しません。 | iOS では、コントロールの視覚的構造を編集する簡単な方法は存在しません。 | コントロールの視覚的な構造をカスタマイズするには、XAML マークアップで**[コントロール テンプレート](https://msdn.microsoft.com/library/windows/apps/xaml/windows.ui.xaml.controls.controltemplate.aspx)**をコピーして編集します。<br/><br/>[クイック スタート: コントロール テンプレート](https://msdn.microsoft.com/library/windows/apps/xaml/hh465374.aspx)  |
|  **組み込みのタッチ ジェスチャ。** ビューやコントロールでタップやダブルタップなどの高レベルの抽象化されたジェスチャ イベントを処理して、カスタマイズされたタッチをサポートします。 | **ジェスチャ ディテクター**が、スクロール、長押し、タップ、ダブルタップ、フリックなどの一般的なタッチ ジェスチャを検出します。 | UIKit フレームワークで提供される組み込みの**ジェスチャ認識エンジン**が、タップ、ピンチ、パン、スワイプ、回転、長押しなどのタッチ ジェスチャを検出します。 | **UI 要素**を使って、タップ、ダブルタップ、右タップ、ホールドなどの**静的ジェスチャ イベント**だけでなく、スライド、スワイプ、回転、ピンチ、ストレッチなどの**操作ジェスチャ イベント**を処理できます。 ジェスチャ イベントは**ルーティング イベント**であり、UIElement の子が含まれている親オブジェクトを使って処理できます。<br/><br/>[タッチ操作](https://msdn.microsoft.com/library/windows/apps/mt185617.aspx)<br/><br/>[カスタム ユーザー操作 - ジェスチャ、操作、対話式操作](https://msdn.microsoft.com/library/windows/apps/mt185599.aspx#gestures__manipulations__and_interactions) |

## ナビゲーションとアプリの構造

|  **一般的な概念** | **Android** | **iOS** | **Windows 10** |
|  ------ | ------ | ------ | ------ |
|  **レイアウト。** レイアウトでは、ユーザー インターフェイスの構造を定義します。 | レイアウトは、他のビュー グループやビューを入れ子にできる **LinearLayout** や **RelativeLayout** などの**ビュー グループ**で構成されます。 | レイアウトは、入れ子にできる **UIView** が含まれる **UIViewController** で構成されます。  | XAML が、静的レイアウトやレスポンシブ レイアウト用の **[Canvas](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.canvas.aspx)**、**[Grid](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.grid.aspx)**、**[RelativePanel](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.relativepanel.aspx)**、**[StackPanel](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.stackpanel.aspx)** などの**レイアウト パネル クラス**から成る柔軟なレイアウト システムを提供します。 **[プロパティ](https://msdn.microsoft.com/library/ms171352.aspx)**を使って要素のサイズと位置を制御します。<br/><br/>[XAML を使ったレイアウトの定義](https://msdn.microsoft.com/library/windows/apps/mt228350.aspx)<br/> |
|  **ピア ツー ピアのナビゲーション。** 階層の重要度が同じページ間を移動する方法をユーザーに提供します。 | **タブ**、**スワイプ ビュー**、**ナビゲーション ドロワー**で**水平方向ナビゲーション**ができます。 | **タブ バー コントローラー**、**分割ビュー コントローラー**、**ページ ビュー コントローラー**で同じ階層のビューの間を移動できます。 | **
            [タブ/ピボット](https://msdn.microsoft.com/library/windows/apps/dn997788.aspx)**を使って、コンテンツの上にあるリンクやタブの永続的な一覧を表示できます。 **
            [ナビゲーション ウィンドウと分割ビュー](https://msdn.microsoft.com/library/windows/apps/dn997787.aspx)**で、コンテンツと共にリンクの一覧を表示することができます。<br/><br/>[ナビゲーション](https://msdn.microsoft.com/library/windows/apps/mt187344.aspx)<br/><br/>[2 ページ間でのピア ツー ピアのナビゲーション](https://msdn.microsoft.com/library/windows/apps/mt465735.aspx) |
|  **階層型ナビゲーション。** 階層の親と子のページ間を移動します。 | 他の**アクティビティ**を読み込む**インテント**と一緒に**リスト**、**グリッド リスト**、**ボタン**などのコントロールを使うと、**子孫のナビゲーション**ができます。 | **ナビゲーション コントローラー**を使うと、ユーザーが階層のレベルの間を移動できます。 | **[ハブ](https://msdn.microsoft.com/library/windows/apps/dn449149.aspx)**を使うと、子ページに移動する場合に選ぶことができるコンテンツのプレビューをユーザーに表示できます。 **[マスター/詳細](https://msdn.microsoft.com/library/windows/apps/dn997765.aspx)**を使うと、ユーザーは対応する [詳細] セクションの横に表示される項目の概要の一覧から項目を選ぶことができます。<br/><br/>[ナビゲーション](https://msdn.microsoft.com/library/windows/apps/mt187344.aspx) |
|  **[戻る] ボタンによるナビゲーション。** アプリケーション内で元の画面に戻ります。 | アクション バーの **[戻る]** ボタンと **[上へ]** ボタンで、**バック スタック**を使って**先祖**ナビゲーションと**一時的な**ナビゲーションができます。 | **ナビゲーション コントローラー**に [戻る] ボタンを追加することができます。<br/> | **
            [バック スタック プロパティ](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.frame.backstack.aspx)**を使ってソフトウェアまたはハードウェアの [戻る] ボタン入力を簡単に処理できます。ユーザーは**ナビゲーション履歴**を移動できます。<br/><br/>[[戻る] ボタンによるナビゲーション](https://msdn.microsoft.com/library/windows/apps/mt465734.aspx) |
|  **スプラッシュ画面。** アプリ起動時にイメージを表示します。主にブランディング目的です。 | スプラッシュ画面は既定では指定されていません。最初のアクティビティの**テーマの背景**を編集すると実装されます。 | **静的起動イメージ**または**XIB/ストーリーボードの起動ファイル**がアプリに必要です。 | **イメージ**とカラーの背景を使ってスプラッシュ画面を作成できます。 [スプラッシュ画面の時間を延ばすことができます](https://msdn.microsoft.com/library/windows/apps/mt187309.aspx)。<br/><br/>[スプラッシュ画面の追加](https://msdn.microsoft.com/library/windows/apps/mt187306.aspx)<br/><br/>[スプラッシュ画面のガイドライン](https://msdn.microsoft.com/library/windows/apps/hh465338.aspx) |

## カスタムの入力

|  **一般的な概念** | **Android** | **iOS** | **Windows 10** |
|  ------ | ------ | ------ | ------ |
|  **音声。** 音声入力に対する音声認識と、その他の音声機能。 | **Google 音声検索**などの **RecognizerIntent** を実装するアプリで音声入力を提供できます。 **SpeechRecognizer** クラスを使うと、アプリで Google の音声認識 API を使うことができます。 | 組み込みの音声認識または音声入力 API はありません。 | **
            [音声認識](https://msdn.microsoft.com/library/windows/apps/mt185615.aspx)** API を使ってフォアグラウンドでアプリを操作できます。 音声認識に基づく **[Cortana の操作](https://msdn.microsoft.com/library/windows/apps/mt185598.aspx)**で、フォアグラウンドまたはバックグラウンドでアプリを起動したり、バックグラウンドのアプリを操作したりできます。<br/><br/>[音声操作](https://msdn.microsoft.com/library/windows/apps/mt185614.aspx) |
|  **カスタムのユーザー入力。** キーボード、マウス、スタイラスなどの入力を処理します。 | **タッチ**、**タッチパッド**、**スタイラス**、**マウス**、**キーボード**の操作がサポートされています。 移動と入力はタッチ操作と同じ方法で報告されますが、**入力デバイス**に関する詳しい情報を検出することができます。 | **タッチ**、**Apple Pencil**、ハードウェア **キーボード**がサポートされています。 | **
            [タッチ](https://msdn.microsoft.com/library/windows/apps/mt185617.aspx)**、**[タッチパッド](https://msdn.microsoft.com/library/windows/apps/mt187313.aspx)**、デジタル インクを使った**[ペン/スタイラス](https://msdn.microsoft.com/library/windows/apps/mt187311.aspx)**、**[マウス](https://msdn.microsoft.com/library/windows/apps/mt187308.aspx)**、**[キーボード](https://msdn.microsoft.com/library/windows/apps/mt185607.aspx)**など、さまざまな操作がサポートされています。 どの入力デバイスが使われたかわからなくても、アプリがデータを処理し、必要に応じて未加工入力デバイス データにアクセスできます。<br/><br/>[ポインター入力の処理](https://msdn.microsoft.com/library/windows/apps/mt404610.aspx)<br/><br/>[カスタム ユーザー操作](https://msdn.microsoft.com/library/windows/apps/mt185599.aspx) |

## データ

|  **一般的な概念** | **Android** | **iOS** | **Windows 10** |
|  ------ | ------ | ------ | ------ |
|  **ローカル アプリ データ。** アプリに関連する設定とファイルをローカルに保存します。 | **openFileOutput** と **openFileInput** を使ってローカル ファイルを保存することができます。 **getSharedPreferences** を使って**共有環境設定ファイル**の設定にアクセスできます。 | **NSFileManager** クラスを使ってアクセスする**アプリケーション サポート** ディレクトリにローカル ファイルを保存できます。 **NSUserDefaults** クラスを使って**環境設定**ファイルの設定にアクセスできます。 | **
            [Windows.Storage](https://msdn.microsoft.com/library/windows/apps/xaml/br230562.aspx)** クラスは、統一された方法でローカルのデータ記憶域を処理します。 **
            [ApplicationData.LocalSettings](https://msdn.microsoft.com/library/windows/apps/xaml/windows.storage.applicationdata.localsettings.aspx)** プロパティを使ってアクセスする **[ApplicationDataContainer](https://msdn.microsoft.com/library/windows/apps/xaml/windows.storage.applicationdatacontainer.aspx)** オブジェクトとして設定を保存します。 **
            [ApplicationData.LocalFolder](https://msdn.microsoft.com/library/windows/apps/xaml/windows.storage.applicationdata.localfolder.aspx)** プロパティを使ってアクセスする **[StorageFolder](https://msdn.microsoft.com/library/windows/apps/windows.storage.storagefolder.aspx)** オブジェクトにファイルを保存します。<br/><br/>[設定と他のアプリ データを保存して取得する](https://msdn.microsoft.com/library/windows/apps/xaml/mt299098.aspx) |
|  **ローカル データベースの記憶域。** リレーショナル データベースにアプリ データを保存します。該当する場合はオブジェクト リレーショナル マッパー (ORM) も一緒に保存します。 | **SQLite** データベースが提供されます。 ORM は組み込みではありません。 **SQLiteDatabase** クラスを使って SQL のクエリが実行されます。 | **SQLite** データベースが提供されます。 **CoreData** は組み込みのオブジェクト グラフのフレームワークで、SQLite と一緒に使うことができ、ORM と同様の機能を提供します。 | **SQLite** を使ってデータを保存することができます。 **[Entity Framework](https://msdn.microsoft.com/library/windows/apps/xaml/mt592863.aspx)** は、多くのデータ アクセス コードを記述する必要がなくなる組み込みの ORM で、SQL を記述しなくてもデータベースに簡単にクエリを実行できます。 [SQLite ライブラリ](https://msdn.microsoft.com/library/windows/apps/xaml/mt592864.aspx) で直接、SQL のクエリを実行できます。<br/><br/>[データ アクセス](https://msdn.microsoft.com/library/windows/apps/xaml/mt592862.aspx) |
|  **REST アクセス用の HTTP ライブラリ。** HTTP(S) を使って Web サービスや Web サーバーと通信できる組み込みのライブラリ。<br/> | HTTP ライブラリ **HttpURLConnection** と **Volley**。 | **NSURLSession**、**NSURLConnection**、**NSURLDownload**。 | 組み込みの **[HttpClient](https://msdn.microsoft.com/library/windows/apps/xaml/windows.web.http.httpclient)** API を使って、GET、DELETE、PUT、POST、一般的な認証パターン、SSL、Cookie、進行状況情報などの一般的な HTTP 機能にアクセスできます。 |
|  **クラウド バックアップ サービス。** プラットフォームで提供される、アプリのデータ バックアップ サービス。  | Android の**バックアップ マネージャー**が Google の **Android バックアップ サービス**でアプリケーション データのバックアップを処理します。  | アプリ データなどのバックアップを処理するようにユーザーが **iCloud バックアップ**を構成できます。 iCloud と互換性のある**コア データ**、**iCloud のキー値ストア**、**iCloud ドキュメント ストレージ**を使うアプリ。 | ローミング **[ApplicationData API](https://msdn.microsoft.com/library/windows/apps/windows.storage.applicationdata.aspx)** (**[RoamingFolder](https://msdn.microsoft.com/library/windows/apps/windows.storage.applicationdata.roamingfolder.aspx)** と [**RoamingSettings**](https://msdn.microsoft.com/library/windows/apps/windows.storage.applicationdata.roamingsettings.aspx) を含む) を使って保存したアプリ データは、自動的にクラウドおよびユーザーの他のデバイスと同じ状態に保たれます。 最新に保つ処理は、ユーザーの Microsoft アカウントで実行されます。<br/><br/>[アプリのデータのローミングのガイドライン](https://msdn.microsoft.com/library/windows/apps/hh465094.aspx) |
|  **HTTP ファイルのダウンロード。** 大小のファイルを HTTP 経由でダウンロードします。 | **URLConnection** と **HTTPURLConnection** を使って HTTP と FTP 経由でダウンロードを行います。また、システムの**ダウンロード マネージャー**を使ってバックグラウンドでダウンロードすることもできます。 | **NSURLSession** と **NSURLConnection** を使って HTTP と FTP 経由でファイルをダウンロードできます。 | **
            [バックグラウンド転送 API](https://msdn.microsoft.com/library/windows/apps/windows.networking.backgroundtransfer.aspx)** で、アプリの中断と接続の切断を考慮し、接続性とバッテリー残量に基づいて調整を行いながら、HTTP(S) と FTP 経由でファイルを確実に転送することができます。 小さなファイルに適した **[HttpClient](https://msdn.microsoft.com/library/windows/apps/windows.web.http.httpclient.aspx)** を使用することもできます。<br/><br/>[アプリに適したネットワーク テクノロジ](https://msdn.microsoft.com/library/windows/apps/mt280235.aspx)<br/><br/>[バックグラウンド転送](https://msdn.microsoft.com/library/windows/apps/mt280377.aspx) |
|  **ソケット。** 独自のプロトコルを使って他のデバイスと通信するために、低レベルの UDP データグラムおよび TCP ソケットを作成します。 | **Socket** クラスが TCP ソケットを提供し、**DatagramSocket** クラスが UDP ソケットを提供します。 | **NSStream** と **CFStream** が TCP ソケットを提供し、**CFSocket** が UDP ソケットを提供します。 | **
            [DatagramSocket](https://msdn.microsoft.com/library/windows/apps/br241319)** クラスを使って UDP データグラム ソケットで通信し、**[StreamSocket](https://msdn.microsoft.com/library/windows/apps/br226882)** クラスを使って TCP または Bluetooth RFCOMM 経由で通信できます。<br/><br/>[ネットワークの基本](https://msdn.microsoft.com/library/windows/apps/mt280233.aspx)<br/><br/>[アプリに適したネットワーク テクノロジ](https://msdn.microsoft.com/library/windows/apps/mt280235.aspx)<br/><br/>[ソケットの概要](https://msdn.microsoft.com/library/windows/apps/mt280234.aspx) |
|  **WebSocket。** クライアントとサーバーの間の双方向通信を実現し、リアルタイムにデータを転送できるようにします。 | Android では、組み込みの WebSocket ライブラリは存在しません。 | iOS では、組み込みの WebSocket ライブラリは存在しません。 | 受信通知付きの小さなメッセージ用には **[MessageWebSocket](https://msdn.microsoft.com/library/windows/apps/windows.networking.sockets.messagewebsocket.aspx)** クラス、セクションごとに読み取りできる大きなバイナリ ファイル転送用には **[StreamWebSocket](https://msdn.microsoft.com/library/windows/apps/windows.networking.sockets.streamwebsocket.aspx)** を使って、WebSocket をサポートしているサーバーへの接続をセキュリティ保護できます。<br/><br/>[ネットワークの基本](https://msdn.microsoft.com/library/windows/apps/mt280233.aspx)<br/><br/>[アプリに適したネットワーク テクノロジ](https://msdn.microsoft.com/library/windows/apps/mt280235.aspx)<br/><br/>[WebSocket の概要](https://msdn.microsoft.com/library/windows/apps/mt186447.aspx) |
|  **OAuth のライブラリ。** OAuth のライブラリがサード パーティの OAuth プロバイダーと、プラットフォームに組み込まれているすべてのアカウント管理にアクセスできるようにします。 | 汎用的な OAuth ライブラリは用意されていません。 Google Play サービスの OAuth 認証用に **GoogleAuthUtil** クラスが提供されています。<br/> | 汎用的な OAuth ライブラリは用意されていません。 **アカウント フレームワーク**が、デバイスに既に保存されている Facebook や Twitter などのユーザー アカウントにアクセスできるようにします。 | 汎用的な OAuth ライブラリの **[Web 認証ブローカー](https://msdn.microsoft.com/library/windows/apps/mt270196.aspx)**を使うと、サード パーティの ID プロバイダー サービスに接続することができます。 **
            [資格情報保管ボックス](https://msdn.microsoft.com/library/windows/apps/mt270189.aspx)**を使うと、ユーザーはログインを保存して複数のデバイスで使うことができます。 **
            [Microsoft.live](https://msdn.microsoft.com/library/windows/apps/dn896755.aspx)** 名前空間を使うと、Live SDK の OAuth に簡単にアクセスして Microsoft サービスにアクセスできます。<br/><br/>[認証とユーザー ID](https://msdn.microsoft.com/library/windows/apps/mt270184.aspx)<br/><br/>[Windows.Security.Authentication.Web API ドキュメント](https://msdn.microsoft.com/library/windows/apps/windows.security.authentication.web.aspx)<br/><br/>[WebAuthenticationBroker のコード例](https://github.com/Microsoft/Windows-universal-samples/tree/master/Samples/WebAuthenticationBroker) |

## ツール

|  **一般的な概念** | **Android** | **iOS** | **Windows 10** |
|  ------ | ------ | ------ | ------ |
|  **IDE。** アプリの作成に使うツールセット。 | **Android Studio** と **Eclipse**。Google は Android Studio を使うように開発者に推奨しています。 | **Xcode** | **[Visual Studio](https://www.visualstudio.com/features/universal-windows-platform-vs.aspx)** と **[Blend for Visual Studio](https://msdn.microsoft.com/library/jj171012.aspx)** に、UWP アプリのコードの記述、デザイン、接続、デバッグ、分析、最適化、テストに必要なすべてのツールが含まれています。 Visual Studio では Windows 10 デバイス用の**[エミュレーター](https://msdn.microsoft.com/library/windows/apps/mt188754.aspx)**も提供されているため、さまざまなエミュレートされたデバイスでアプリをテストできます。<br/><br/>[UWP 用のダウンロードとツール](https://dev.windows.com/downloads) |
|  **コードの構成。** 初期テンプレートから作成されることが多い、アプリの基本的なフォルダー構造。 | **AndroidManifest** ファイル、ソース ファイルを含む **java** フォルダー、レイアウトや値などのリソースを持つ **res** フォルダー、Android Studio の **Gradle** ビルド スクリプト、Eclipse の **Ant** ビルド スクリプト。 | ソース ファイルと**サポート ファイル**、**Info.plist** ファイル、**Main.storyboard**、**LaunchScreen.storyboard**。 イメージは**アセット ライブラリ**に格納されます。 | UWP アプリには、Example.xaml や Example.xaml.cs というアプリ用の XAML とコード ファイル、**Assets フォルダー**のさまざまな画像、**MainPage.xaml** や **MainPage.xaml.cs** などのスタート ページ、マニフェストが含まれています。<br/><br/>["Hello, world" アプリを作成する](https://msdn.microsoft.com/library/windows/apps/dn765018.aspx) |

## アプリのライフサイクル

|  **一般的な概念** | **Android** | **iOS** | **Windows 10** |
|  ------ | ------ | ------ | ------ |
|  **アプリのライフサイクル。** アプリの起動時、中断時、再開時、終了時にイベントを処理し、アプリケーションの状態を保存/復元したり他のタスクを実行したりする機会を提供します。 | アクティビティのそれぞれに、**再開**などの状態を持つ独自の**アクティビティ ライフサイクル**があります。 **onResume** などの**ライフサイクル コールバック**が**アクティビティ クラス**に実装されます。 | **アプリケーションのライフサイクル**には**中断**などの状態があります。 **applicationDidEnterBackground:** などのメソッドを**アプリケーションのデリゲート オブジェクト**に実装して、状態が変わったときにコードを実行できます。 | アプリケーションには**アプリの実行状態** NotRunning、Activated、Running、Suspending、Suspended、Resuming があります。<br/><br/>**
            [Application クラス](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.application.aspx)**のメソッド OnLaunched、OnActivated、Suspending、Resuming をアプリに実装して、状態が変わったときにコードを実行できます。<br/><br/>[アプリのライフサイクル](https://msdn.microsoft.com/library/windows/apps/mt243287.aspx) |
|  **バックグラウンド タスク。** バックグラウンド操作を実行し、アプリがフォアグラウンドではなくなったときに動作し続けるタスク。 | アプリは、アプリがフォアグラウンドではなくなったときにバックグラウンド操作を実行する**サービス**を起動できます。 サービスに独自の**ライフサイクル**があり、マニフェストに登録されています。 | **バックグラウンドでの実行**は、特定の種類のタスクのみで許可されます。<br/><br/>アプリは **UIBackgroundModes** を使って、Info.plist ファイルで**サポートされるバックグラウンド タスク**を宣言します。<br/><br/>システムでは、バックグラウンド タスクがいつどれくらいの長さで実行されるかが制御されます。 | バックグラウンド タスクを作成するには、**[IBackgroundTask](https://msdn.microsoft.com/library/windows/apps/windows.applicationmodel.background.ibackgroundtask.aspx)** インターフェイスを実装してアプリケーション マニフェストにタスクを登録します。 [
            **タイマー**](https://msdn.microsoft.com/library/windows/apps/mt186458.aspx)、[**システム トリガー**](https://msdn.microsoft.com/library/windows/apps/windows.applicationmodel.background.systemtriggertype.aspx)、[**メンテナンス トリガー**](https://msdn.microsoft.com/library/windows/apps/mt185632.aspx) でタスクをトリガーするように設定できます。<br/><br/>[バックグラウンド タスクによるアプリのサポート](https://msdn.microsoft.com/library/windows/apps/mt299103.aspx)<br/><br/>[バックグラウンド タスクの作成と登録](https://msdn.microsoft.com/library/windows/apps/mt299100.aspx)<br/><br/>[バックグラウンド タスクのガイドライン](https://msdn.microsoft.com/library/windows/apps/mt187310.aspx) |

## パフォーマンス

|  **一般的な概念** | **Android** | **iOS** | **Windows 10** |
|  ------ | ------ | ------ | ------ |
|  **パフォーマンスのベスト プラクティス。** スタートアップ時間が短く、高速で応答性の高い、バッテリー残量に配慮したアプリを構築するためのガイドライン。 | Android では**パフォーマンスに関するベスト プラクティス**のトレーニング ガイドが提供されています。 | iOS では**パフォーマンスの概要**に関するドキュメントが提供されています。 | パフォーマンスの目標の設定、パフォーマンスの測定、メモリ管理、スムーズなアニメーション、効率的なファイル システムへのアクセス、プロファイリングとパフォーマンスのために使用できるツールなどのトピックが記載されているセクションを含む、詳しい**[パフォーマンス ガイド](https://msdn.microsoft.com/library/windows/apps/mt270266.aspx)**をご覧いただけます。 |
|  **応答性の高い UI のための表示の最適化。** 表示を最適化してパフォーマンスを向上させます。 | 階層ビューアー ツールを使った**レイアウト階層**の最適化、**レイアウトの再利用**、**オンデマンドでのビュー**の読み込みはすべて、UI スレッドの応答性を確保し、「アプリケーションが応答しない」(**ANR**) というダイアログを回避するための手法です。<br/> | **コア アニメーション** ツールを使って**オフスクリーン レンダリング**、**ブレンド レイヤー**、**ラスタライズ**で UI の問題を修正すると、UI スレッドの応答性を確保しやすくなります。 | いくつかの簡単な手順を実行すると、XAML の**マークアップ**と**レイアウト**を簡単に**最適化**できます。 レイアウト構造の簡素化、要素数の最小化、過剰な描画の最小化などの手法を利用できます。 <br/><br/>[UI スレッドの応答性の確保](https://msdn.microsoft.com/library/windows/apps/mt185403.aspx)<br/><br/>[XAML マークアップの最適化](https://msdn.microsoft.com/library/windows/apps/mt204779.aspx)<br/><br/>[XAML レイアウトの最適化](https://msdn.microsoft.com/library/windows/apps/mt404609.aspx) |
|  **スレッド処理。** **UI の応答性**を確保し、複数**タスクを並行**して実行するためにスレッド処理を使用します。 | スレッド処理を行うには、**Runnable**、**Handler**、**ThreadPoolExecutor** の各クラスと、上位レベルの **AsyncTask** クラスを使います。 | スレッド処理を行うには、**NSThread**、**Grand Central Dispatch**、上位レベルの **NSOperation** を使います。 | スレッドを使用するには、**[RunAsync](https://msdn.microsoft.com/library/windows/apps/windows.system.threading.threadpool.runasync.aspx)** で**作業項目**を**スレッド プール**に送信します。 **
            [CreateTimer](https://msdn.microsoft.com/library/windows/apps/br230590.aspx)** でタイマーを使って作業項目を送信したり、**[CreatePeriodicTimer](https://msdn.microsoft.com/library/windows/apps/br230589.aspx)** で繰り返しの作業項目を作成したりできます。<br/><br/>[スレッド プールへの作業項目の送信](https://msdn.microsoft.com/library/windows/apps/mt187339.aspx)<br/><br/>[タイマーを使った作業項目の送信](https://msdn.microsoft.com/library/windows/apps/mt187341.aspx)<br/><br/>[定期的な作業項目の作成](https://msdn.microsoft.com/library/windows/apps/mt187338.aspx)<br/><br/>[スレッド プールを使うためのベスト プラクティス](https://msdn.microsoft.com/library/windows/apps/mt187336.aspx) |
|  **非同期プログラミング。** UI スレッドの応答性を確保するために、非同期プログラミング パターンを利用してスレッドが複雑にならないようにします。  | 独自の非同期クラスを作成するには**スレッド処理を使う必要があります**。 一部の組み込みクラスは非同期です。 | 独自の非同期クラスを作成するには**スレッド処理を使う必要があります**。 一部の組み込みクラスは非同期です。 | 独自の API を作成するときにメイン スレッドをブロックしないように、非同期パターンを使うことができます。たとえば、C# と Visual Basic で **async** や **await** を使うことができます。 語が **Async** で終わる非同期の組み込み API を使うことができます。<br/><br/>[非同期プログラミング](https://msdn.microsoft.com/library/windows/apps/mt187335.aspx)<br/><br/>[C# または Visual Basic での非同期 API の呼び出し](https://msdn.microsoft.com/library/windows/apps/mt187337.aspx) |
|  **リスト ビューの最適化。** 大量のデータを表示する必要がある場合にパフォーマンスを低下させることが多い、データの一覧の最適化を支援する組み込みのパターン | **ViewHolder** デザイン パターンを使って複数のビュー参照を避け、再利用可能な UI 要素を使うことができます。 | **UITableView** のパフォーマンスを向上させるさまざまな最適化を行うことができます。組み込まれているものはありません。 | 既定で **UI の仮想化** を提供する [ListView](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.listview.aspx) と [GridView](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.gridview.aspx) の各コントロールを使うと、スムーズなパンやスクロール、起動時間の短縮を実現できます。 [IList](https://msdn.microsoft.com/library/windows/apps/system.collections.ilist.aspx) と [INotifyCollectionChanged](https://msdn.microsoft.com/library/windows/apps/system.collections.specialized.inotifycollectionchanged.aspx) をデータ ソースに実装し、**データ仮想化**を行ってパフォーマンスをさらに改善することもできます。<br/><br/>[ListView と GridView の UI の最適化](https://msdn.microsoft.com/library/windows/apps/mt204776.aspx)<br/><br/>[ListView と GridView のデータ仮想化](https://msdn.microsoft.com/library/windows/apps/mt574120.aspx) |

## 収益化

|  **一般的な概念** | **Android** | **iOS** | **Windows 10** |
|  ------ | ------ | ------ | ------ |
|  **アプリ内購入。** ユーザーがアプリで購入を行うことができるプラットフォーム機能です。 | **アプリ内課金**は Google サービスで提供されています。 製品は **Google Play デベロッパー コンソール**に追加されます。 アプリ内購入を実装するには、**Google Play Billing Library** を使います。 | 製品は **iTunes Connect** に追加されます。 アプリ内購入を実装するには、**StoreKit** フレームワークを使います。<br/><br/>製品を購入するには、**SKMutablePayment** と **SKPaymentQueue** を使います。 | アプリでアプリ内製品の購入を作成するには、[アプリに追加してストアに申請](https://msdn.microsoft.com/library/windows/apps/mt148551.aspx) します。 <br/><br/>アプリ内購入を定義するには、**[CurrentApp クラス](https://msdn.microsoft.com/library/windows/apps/windows.applicationmodel.store.currentapp.aspx)**を使います。 <br/><br/>**
            [CurrentApp.RequestProductPurchaseAsync](https://msdn.microsoft.com/library/windows/apps/windows.applicationmodel.store.currentapp.requestproductpurchaseasync.aspx)** を使うと、ユーザーが製品を購入するための UI を表示できます。<br/><br/>[アプリ内製品購入の有効化](https://msdn.microsoft.com/library/windows/apps/mt219684.aspx) |
|  **コンシューマブルなアプリ内購入。** 購入して使った後でもう一度購入できるアプリ内製品。 | 通常の購入後に **consumePurchase** で製品を使うと、コンシューマブルな購入が有効になり、購入して使った後でもう一度購入できます。 | コンシューマブルな製品は iTunes Connect で**コンシューマブルな製品として定義**されます。 | コンシューマブルをサポートするには、ストアに [申請するときに製品の種類をコンシューマブルと定義](https://msdn.microsoft.com/library/windows/apps/mt148534.aspx) します。 次に、ユーザーがコンシューマブルな購入を利用できるようになったら **[CurrentApp.ReportConsumableFulfillmentAsync](https://msdn.microsoft.com/library/windows/apps/windows.applicationmodel.store.currentapp.reportconsumablefulfillmentasync.aspx)** を呼び出します。<br/><br/>[コンシューマブルなアプリ内購入の有効化](https://msdn.microsoft.com/library/windows/apps/mt219683.aspx) |
|  **アプリ内購入のテスト。** アプリをストアに配置せずに、アプリ内購入コードをテストできるようにします。 | **アプリ内課金サンドボックス**を使ってテストします。  | **Sandbox テスター アカウント**を使ってテストします。 | CurrentApp の代わりに **[CurrentAppSimulator](https://msdn.microsoft.com/library/windows/apps/windows.applicationmodel.store.currentappsimulator.aspx)** クラスを使うだけでアプリ内購入をテストできます。<br/><br/> |
|  **試用版。** 簡単にコンテンツを制限したり、アプリの試用版に基づく広告を削除したりできるようにします。 | Google Play は**アプリの試用版を公式にサポートしていません**。 試用または広告の削除を行うには、アプリ内購入を作成し、購入の確認時に適切なコード パスを実行します。 | App Store は**アプリの試用版を公式にサポートしていません**。 試用または広告の削除を行うには、アプリ内購入を作成し、購入の確認時に適切なコード パスを実行します。 | アプリの無料試用版を提供するには、ストアにアプリを申請するときに **['無料試用版' オプション](https://msdn.microsoft.com/library/windows/apps/mt148548.aspx)** を使います。 その後、**[LicenseInformation.IsTrial](https://msdn.microsoft.com/library/windows/apps/windows.applicationmodel.store.licenseinformation.istrial.aspx)** を使ってアプリの試用の状態を確認し、それに応じて異なるコード パスを指定します。 アプリの実行中にユーザーが試用の状態を変更した場合に [LicenseChanged イベント](https://msdn.microsoft.com/library/windows/apps/windows.applicationmodel.store.licenseinformation.licensechanged) が通知されるように登録できます。<br/><br/>[試用版での機能の除外または制限](https://msdn.microsoft.com/library/windows/apps/mt219685.aspx) |

## 複数のプラットフォームへの対応

|  **一般的な概念** | **Android** | **iOS** | **Windows 10** |
|  ------ | ------ | ------ | ------ |
|  **アダプティブ UI: 柔軟なレイアウト。** 柔軟な高さと幅の、さまざまな画面サイズをサポートします。 | 柔軟なレイアウトにするには、LinearLayout オブジェクトで **wrap_content** と **match_parent** の値を使うか、RelativeLayout オブジェクトを使って配置します。 | 柔軟なレイアウトにするには、ユニバーサル ストーリーボードと一緒に**アダプティブ モデル**を使い、表示コントローラーに適用される horizontalSizeClass や displayScale などの**制約**や**特性**と一緒に**自動レイアウト**を利用します。 | 柔軟なレイアウトを作成するには、固定サイズ指定と動的なサイズ指定を組み合わせて**レイアウト プロパティ**と**パネル**を使います。<br/><br/>[XAML を使ったレイアウトの定義 - レイアウト プロパティとパネル](https://msdn.microsoft.com/library/windows/apps/mt228350.aspx#layout_overview)<br/><br/>[レスポンシブ デザイン 101](https://msdn.microsoft.com/library/windows/apps/dn958435.aspx) |
|  **アダプティブ UI: カスタマイズされたレイアウト。** 別の対象となるレイアウトを使った、さまざまな画面サイズをサポートします。 | **small**、**large**、**ldpi**、**hdpi** などの**構成修飾子**を使ってリソース ディレクトリにさまざまな画面構成用の代替レイアウト ファイルを指定すると、さまざまなサイズと密度の画面にカスタム レイアウトを適用できます。 | **iPhone と iPad で別々のストーリーボード**を定義すると、ユニバーサルアプリで異なるデバイス ファミリに合わせてレイアウトを調整できます。 | カスタマイズされたレイアウトを作るには、デバイス ファミリごとに**別の XAML マークアップ ファイル**を定義します。<br/><br/>[XAML を使ったレイアウトの定義 - カスタマイズされたレイアウト](https://msdn.microsoft.com/library/windows/apps/mt228350.aspx#tailored_layouts) |
|  **アダプティブ UI: レスポンシブ レイアウト。** 回転などの画面サイズの変更やウィンドウのサイズの変更へ反応します。 | **LinearLayout** や **RelativeLayout** と一緒に柔軟なレイアウトを使うか、異なる方向用の代替レイアウト ファイルを提供すると、レスポンシブ レイアウトを使うことができます。 | 表示の**サイズ**や**特性**が変化すると、ストーリーボードに指定されている**制約**が適用されます。 | **
            [VisualState](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.visualstate.aspx)**、**[VisualStateManager](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.visualstatemanager.aspx)**、**[AdaptiveTrigger](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.adaptivetrigger.aspx)** を使い、ウィンドウ サイズの変更に基づいて実行時に UI のセクションの再配置、位置の変更、サイズの変更、表示、置換を簡単に行うことができます。<br/><br/>[XAML を使ったレイアウトの定義 - 表示状態と状態トリガー](https://msdn.microsoft.com/library/windows/apps/mt228350.aspx#visual_states_and_state_triggers)<br/><br/>[レスポンシブ デザイン 101](https://msdn.microsoft.com/library/windows/apps/dn958435.aspx) |
|  **別のデバイス機能のサポート。** 高度なハードウェア機能に対応しながら、それらの機能を備えていないデバイスもサポートします。 | **PackageManager.hasSystemFeature** を使ってデバイス機能を実行時にテストすると、ハードウェア固有のコードを実行できるかどうかを判断することができます。 | 実行時にデバイス機能をテストするために行える**単一のチェックはありません**。各機能を異なる方法でテストして、ハードウェア固有のコードを実行できるかどうかを判断します。 | 電話、デスクトップ、IoT など、別のデバイス ファミリの追加機能を対象にした**プラットフォーム拡張 SDK** をパッケージに追加できます。 **
            [ApiInformation API](https://msdn.microsoft.com/library/windows/apps/windows.foundation.metadata.apiinformation.aspx)** を使って実行時に種類とメンバーの存在をテストし、存在している場合のみ、それらの種類とメンバーを呼び出すことができます。 |
|  **別のデバイス機能のサポート。** 高度なハードウェア機能に対応しながら、それらの機能を備えていないデバイスもサポートします。 | **Android サポート ライブラリ**をアプリにパッケージして、以前のバージョンの Android ユーザーがいくつかの新しい API を利用できるようにします。 実行時に API レベルのテストを行うには、**Build.Version.SDK_INT** を使います。 | クラスが存在するかどうかを確認する **class** メソッドやクラスのメソッドを確認する **respondsToSelector:** など、標準的なランタイム チェックを使って API が利用できるかどうかを調べます。  | **
            [ApiInformation.IsApiContractPresent](https://msdn.microsoft.com/library/windows/apps/dn949005.aspx)** を使って、指定したメジャー数とマイナー数の API コントラクトが存在するかどうかを特定できます。 また、**[ApiInformation API](https://msdn.microsoft.com/library/windows/apps/windows.foundation.metadata.apiinformation.aspx)** を使って実行時に種類とメンバーの存在をテストし、存在している場合のみ、それらの種類とメンバーを呼び出すことができます。 |

## 通知

|  **一般的な概念** | **Android** | **iOS** | **Windows 10** |
|  ------ | ------ | ------ | ------ |
|  **タイルとバッジ。** ホーム画面上でユーザーに更新プログラムを表示します。 | **アプリのウィジェット**は、ホーム画面に埋め込むことができ、定期的な更新プログラムを受け取ることができる、アプリケーションのビューです。 Android には**バッジ システム**は存在しません。 タイルと同じシステムは存在しません。 | iOS には**タイルやウィジェット**は存在しません。 ローカルまたはリモートの通知に基づいて変更できる数字付きで、**バッジ**をアイコンに追加することができます。 | アプリにはスタート画面にピン留めできる**タイル**があり、装飾文字と数字付きで選択したテキスト、画像、**バッジ**を表示するために使うことができます。 プッシュ通知または定義済みのスケジュールに基づいて、アプリからタイルのコンテンツを更新することができます。 タイルはアダプティブにでき、表示される場所に従って変更できます。<br/><br/>[タイルの作成](https://msdn.microsoft.com/library/windows/apps/xaml/mt185605.aspx)<br/><br/>[アダプティブ タイルの作成](https://msdn.microsoft.com/library/windows/apps/xaml/mt590880.aspx)<br/><br/>[通知配信方法の選択](https://msdn.microsoft.com/library/windows/apps/xaml/mt187193.aspx)<br/><br/>[タイルとバッジのガイドライン](https://msdn.microsoft.com/library/windows/apps/xaml/hh465403.aspx) |
|  **通知の表示。** 表示できる通知の種類。 | 通知を表示できるのは**通知領域**と**通知ドロワー**で、**ヘッドアップ通知**では小さなフローティング ウィンドウに通知が表示されます。 **PendingIntent** を定義すると、通知に操作を追加できます。 | ポップアップ通知は**バナー**または**警告**として表示されます。 **UIMutableUserNotificationAction** で定義する**操作可能な通知**にカスタム操作のボタンを追加できます。 | **トースト通知**と呼ばれるアダプティブ ポップアップ通知を作成できます。 視覚的なコンテンツ、ボタンや入力などの**操作**、オーディオを使って、XML でトースト通知を定義できます。<br/><br/>[アダプティブ トースト通知と対話型トースト通知](https://msdn.microsoft.com/library/windows/apps/xaml/mt631604.aspx)<br/><br/>[通知配信方法の選択](https://msdn.microsoft.com/library/windows/apps/xaml/mt187193.aspx)<br/><br/>[トースト通知のガイドライン](https://msdn.microsoft.com/library/windows/apps/xaml/hh465391.aspx) |
|  **ローカル通知のスケジュール。** スケジュールされた時刻にアプリから送信されるローカル通知。 | 通知とアクションは **NotificationCompat.Builder** を使って定義し、**AlarmManager** と **BroadcastReceiver** を使ってアプリ内でスケジュール設定したり処理したりできます。 | ローカル通知は **UILocalNotification** を使って作成し、** UILocalNotification.scheduleLocalNotification:** でスケジュール設定できます。 | トースト通知は **[ScheduledToastNotification](https://msdn.microsoft.com/library/windows/apps/xaml/windows.ui.notifications.scheduledtoastnotification.aspx)** を使ってスケジュール設定できます。 タイル通知をアプリから送信するには **[TileNotification クラス](https://msdn.microsoft.com/library/windows/apps/xaml/windows.ui.notifications.tilenotification.aspx)** を使い、タイル通知をスケジュール設定するには [ScheduledTileNotification](https://msdn.microsoft.com/library/windows/apps/xaml/windows.ui.notifications.scheduledtilenotification.aspx) を使います。<br/><br/>[アダプティブ トースト通知と対話型トースト通知](https://msdn.microsoft.com/library/windows/apps/xaml/mt631604.aspx)<br/><br/>[ローカル タイル通知の送信](https://msdn.microsoft.com/library/windows/apps/xaml/mt593299.aspx) |
|  **プッシュ通知の送信。** プッシュ通知のサーバーから送信され、必要に応じてアプリで処理される通知。 | **Google Cloud Messaging** が Android のプッシュ通知のサポートを提供します。 | リモート通知またはプッシュ通知は **Apple Push Notification Service (APNS)** で提供されます。 | プッシュ通知は **Windows プッシュ通知サービス (WNS)** から送られます。タイル、トースト、バッジ、または直接通知を送ることができます。 [PushNotificationReceived](https://msdn.microsoft.com/library/windows/apps/xaml/windows.networking.pushnotifications.pushnotificationchannel.pushnotificationreceived.aspx) 通知配信イベントを使うと、アプリの実行中に通知を受け取ることができます。<br/><br/>[Windows プッシュ通知サービス (WNS) の概要](https://msdn.microsoft.com/library/windows/apps/xaml/mt187203.aspx)<br/><br/>[直接通知の概要](https://msdn.microsoft.com/library/windows/apps/xaml/mt187200.aspx) |

## メディアのキャプチャとレンダリング

|  **一般的な概念** | **Android** | **iOS** | **Windows 10** |
|  ------ | ------ | ------ | ------ |
|  **メディアのキャプチャ。** オーディオとビジュアルのコンテンツを記録します。 | MediaStore.ACTION_VIDEO_CAPTURE などの**インテント**を使うと、既存のカメラ アプリでメディアをキャプチャできます。 **android.hardware.camera2** または **camera** ライブラリを使うと、カメラのカスタム インターフェイスを実装できます。 **MediaRecorder** API を使うと、オーディオをキャプチャできます。 | **UIImagePickerController** を使うと、システム UI でビデオと写真をキャプチャできます。 **AVCaptureSession** などの **AVFoundation** クラスを使うと、カメラへ直接アクセスできます。 <br/>**AVAudioRecorder** クラスを使うと、オーディオを録音できます。 | **
            [CameraCaptureUI クラス](https://msdn.microsoft.com/library/windows/apps/xaml/windows.media.capture.cameracaptureui.aspx)**を使うと、組み込みのカメラ UI を使いながら写真とビデオをキャプチャできます。 **
            [MediaCapture API](https://msdn.microsoft.com/library/windows/apps/xaml/windows.media.capture.mediacapture.aspx)** などの **[Windows.Media.Capture](https://msdn.microsoft.com/library/windows/apps/xaml/windows.media.capture.aspx)** のクラスを使って、低レベルのカメラ操作でオーディオをキャプチャできます。 <br/><br/>[CameraCaptureUI を使った写真とビデオのキャプチャ](https://msdn.microsoft.com/library/windows/apps/xaml/mt282142.aspx)<br/><br/>[MediaCapture を使った写真とビデオのキャプチャ](https://msdn.microsoft.com/library/windows/apps/xaml/mt243896.aspx) |
|  **メディア再生。** オーディオとビデオのファイルを再生します。 | **MediaPlayer** クラスと **AudioManager** クラスを使うと、オーディオとビデオのファイルを再生できます。 | **AVKit フレームワーク**、**AVAudioPlayer**、**Media Player Framework** を使うと、オーディオとビデオのファイルを再生できます。 | **
            [MediaSource クラス](https://msdn.microsoft.com/library/windows/apps/xaml/windows.media.core.mediasource.aspx)**、**[MediaElement](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.mediaelement.aspx)**、**[MediaPlayer](https://msdn.microsoft.com/library/windows/apps/windows.media.playback.mediaplayer.aspx)** クラスを使うと、ローカル ファイルやリモート ファイルなどのソースからオーディオとビデオを再生できます。<br/><br/>[MediaSource を使ったメディアの再生](https://msdn.microsoft.com/library/windows/apps/xaml/mt592657.aspx) |
|  **メディアの編集。** 既存の録音や録画から新しいメディア ファイルを作成し、特殊効果を適用します。 | **MediaCodec**、**MediaMuxer**、**android.media.effect** などの低レベルのクラスを使ってコンテンツを編集できます。 | **AV Foundation** フレームワークの **AVMutableComposition**、**AVMutableVideoComposition**、**AVMutableAudioMix** などのクラスを使ってコンテンツを編集できます。 | **
            [MediaComposition](https://msdn.microsoft.com/library/windows/apps/windows.media.editing.mediacomposition.aspx)**、**[MediaClip](https://msdn.microsoft.com/library/windows/apps/windows.media.editing.mediaclip.aspx)** などの **[Windows.Media.Editing](https://msdn.microsoft.com/library/windows/apps/windows.media.editing.aspx)** API を使って、オーディオやビデオのファイルからメディア コンポジションを作成できます。 ビデオと画像のオーバーレイの追加、ビデオ クリップの結合、バックグラウンド オーディオの追加、オーディオとビデオの効果の適用を行うことができます。<br/><br/>[メディア コンポジションと編集](https://msdn.microsoft.com/library/windows/apps/mt204792.aspx) |

## センサー

|  **一般的な概念** | **Android** | **iOS** | **Windows 10** |
|  ------ | ------ | ------ | ------ |
|  **センサー。** デバイスの動き、位置、環境のプロパティを検出します。 | **SensorManager** や **SensorEvent** などのクラスを使うと、**センサー フレームワーク**を使ってハードウェアとソフトウェアのセンサーにアクセスできます。  | **Core Motion フレームワーク**を使うと、センサーの生データと処理されたデータにアクセスできます。 | **
            [Windows.Devices.Sensors](https://msdn.microsoft.com/library/windows/apps/windows.devices.sensors.aspx)** のクラスを使って、センサーの測定値にアクセスしたり、センサーから新しい測定データを受け取ったときにトリガーされたイベントにアクセスしたりできます。<br/><br/>[センサー](https://msdn.microsoft.com/library/windows/apps/xaml/mt187358.aspx) |

## 位置情報とマッピング

|  **一般的な概念** | **Android** | **iOS** | **Windows 10** |
|  ------ | ------ | ------ | ------ |
|  **位置情報。** デバイスの**現在**位置を検出し、**変更**を追跡します。 | Google Play サービスの位置情報 API では、**getLastLocation** メソッドと **requestLocationUpdates** メソッドを使って、**Fused Location Provider** が取得した**最後の既知の位置情報**への高レベルのアクセスを提供します。 低レベルのアクセスは、Android ライブラリの **LocationManager** で提供されます。 | **Core Location** の **CLLocationManager** クラスを使ってデバイスの位置を監視します。**startUpdatingLocation** で標準位置情報サービス、**startMonitoringSignificantLocationChanges** で**大幅変更**位置情報サービスを利用できます。 | デバイスの位置情報を追跡するには、**[Windows.Devices.Geolocation](https://msdn.microsoft.com/library/windows/apps/windows.devices.geolocation.aspx)** のクラスを使います。 1 回限りの読み取りの場合、**[Geolocator.GetGeopositionAsync](https://msdn.microsoft.com/library/windows/apps/br225537.aspx)** を使います。 タイマーを使って位置情報を定期的に取得するか、位置が変わったときに通知を受けるには、**[Geolocator.PositionChanged](https://msdn.microsoft.com/library/windows/apps/windows.devices.geolocation.geolocator.positionchanged.aspx)** を使います。<br/><br/>[ユーザーの位置情報の取得](https://msdn.microsoft.com/library/windows/apps/mt219698.aspx) |
|  **地図の表示。** **組み込みの対話式の地図**を表示し、**関心のあるポイント**を追加します。 | **Google Maps Android API** の **GoogleMap**、**MapFragment**、**MapView** クラスで、アプリに地図を埋め込むことができます。 関心のあるポイントを表示するには、**マーカー**と、カスタマイズ可能な **Marker** クラスを使います。 | 地図を iOS アプリに埋め込むには、**MapKit フレームワーク**の **MKMapView** クラスを使います。 **アノテーション**をアプリに追加し、**MKPointAnnotation** などのオブジェクト クラスや **MKPinAnnotationView** などのビュー クラスを使って関心のあるポイントを表示できます。 | アプリに地図を埋め込むには、2D、3D、Streetside ビューを表示する組み込みの **[MapControl](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.maps.mapcontrol.aspx)** XAML コントロールを使います。 プッシュピン、画像、図形を使って関心のあるポイントを追加するには、**[MapIcon](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.maps.mapicon.aspx)**、**[MapPolygon](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.maps.mappolygon.aspx)**、**[MapPolyline](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.maps.mappolyline.aspx)** などのクラスを使います。<br/><br/>[2D、3D、Streetside ビューでの地図の表示](https://msdn.microsoft.com/library/windows/apps/mt219695.aspx)<br/><br/>[関心のあるポイント (POI) の地図への表示](https://msdn.microsoft.com/library/windows/apps/mt219696.aspx) |
|  **ジオフェンス。** 特定の地理的な地域への進入と退出を監視します。 | ジオフェンスを監視するには、Google Play Services SDK の**位置情報サービス**を使います。 | 地域を監視するには **CLCircularRegion** クラスを使い、登録するには **CLLocationManager.startMonitoringForRegion:** を使います。 | **
            [Geofence](https://msdn.microsoft.com/library/windows/apps/windows.devices.geolocation.geofencing.geofence.aspx)** クラスを使ってジオフェンスを作成し、地域への進入と退出など、**監視する状態**を定義できます。 ジオフェンス イベントをフォアグラウンドで処理するには **[GeofenceMonitor クラス](https://msdn.microsoft.com/library/windows/apps/windows.devices.geolocation.geofencing.geofencemonitor.aspx)**、バックグラウンドで処理するには **[LocationTrigger バックグラウンド クラス](https://msdn.microsoft.com/library/windows/apps/windows.applicationmodel.background.locationtrigger.aspx)**を使います。<br/><br/>[ジオフェンスのセットアップ](https://msdn.microsoft.com/library/windows/apps/mt219702.aspx) |
|  **ジオコーディングと逆ジオコーディング。** 住所を地理的な位置に変換したり (ジオコーディング)、地理的な位置を住所に変換したりします (逆ジオコーディング)。<br/> | ジオコーディングや逆ジオコーディングには **Geocoder** クラスを使います。 | ジオコーディングには **CLGeocoder** クラスを使います。 | ジオコーディングを実行するには、**[Windows.Services.Maps](https://msdn.microsoft.com/library/windows/apps/windows.services.maps.aspx)** の **[MapLocationFinder クラス](https://msdn.microsoft.com/library/windows/apps/windows.services.maps.maplocationfinder.aspx)**を使います。 ジオコーディングには **[FindLocationsAsync](https://msdn.microsoft.com/library/windows/apps/windows.services.maps.maplocationfinder.findlocationsasync.aspx)**、逆ジオコーディングには **[FindLocationsAtAsync](https://msdn.microsoft.com/library/windows/apps/windows.services.maps.maplocationfinder.findlocationsatasync.aspx)** を使います。<br/><br/>[ジオコーディングと逆ジオコーディングの実行](https://msdn.microsoft.com/library/windows/apps/mt219697.aspx) |
|  **ルートとルート案内。** 地理的な 2 つの場所の間のルート、距離、ルート案内を提供します。 | Google は、Android で使うことができる Web サービス **Google Maps Directions API** を提供しています。ただし、SDK は提供されていません。 | Map Kit で提供されている **MKDirections** API を使ってルートとルート案内を取得できます。 | **
            [Windows.Services.Maps](https://msdn.microsoft.com/library/windows/apps/windows.services.maps.aspx)** の **[MapRouteFinder](https://msdn.microsoft.com/library/windows/apps/windows.services.maps.maproutefinder.aspx)** クラスを使って、徒歩ルートや運転ルートを要求できます。 ルートは **[MapRoute](https://msdn.microsoft.com/library/windows/apps/windows.services.maps.maproute.aspx)** インスタンスとして返されるため、MapControl に簡単に表示できます。 ルート案内は **[MapRouteManeuver](https://msdn.microsoft.com/library/windows/apps/windows.services.maps.maproutemaneuver.aspx)** オブジェクト内に返されます。<br/><br/>[地図へのルートとルート案内の表示](https://msdn.microsoft.com/library/windows/apps/mt219701.aspx) |

## アプリ間通信

|  **一般的な概念** | **Android** | **iOS** | **Windows 10** |
|  ------ | ------ | ------ | ------ |
|  **別のアプリの起動。** 別のアプリを起動して、必要に応じてリンク、テキスト、写真、ビデオ、ファイルなどのデータを共有します。 | **インテント**で**アクション**と必要に応じてデータを定義し、**startActivityForResult** で呼び出すと、**暗黙的インテント**を使って別のアプリを起動できます。<br/> | **アプリの拡張機能**を使って、別のアプリにアプリ データへのアクセスを提供できます。 **URL スキーム**を使うと、URL を別のアプリに渡すことができます。 | URI が登録されている別のアプリを起動するには **[Launcher.LaunchUriAsync](https://msdn.microsoft.com/library/windows/apps/windows.system.launcher.launchuriasync.aspx)** を使います。結果を取得するためにアプリを起動し、起動したアプリから返されたデータを取得するには **[Launcher.LaunchUriForResultsAsync](https://msdn.microsoft.com/library/windows/apps/windows.system.launcher.launchuriforresultsasync.aspx)** を使います。 **
            [Launcher.LaunchFileAsync](https://msdn.microsoft.com/library/windows/apps/hh701471.aspx)** を使うと、別のアプリに処理するファイルを渡すことができます。<br/><br/>**共有コントラクト**を使って、アプリ間でデータを簡単に共有できます。<br/><br/>[URI に応じた既定のアプリの起動](https://msdn.microsoft.com/library/windows/apps/mt228340.aspx)<br/><br/>[結果を取得するためのアプリの起動](https://msdn.microsoft.com/library/windows/apps/mt269386.aspx)<br/><br/>[ファイルに応じた既定のアプリの起動](https://msdn.microsoft.com/library/windows/apps/mt299102.aspx)<br/><br/>[データの共有](https://msdn.microsoft.com/library/windows/apps/xaml/mt243293.aspx) |
|  **アプリを呼び出すことができるようにします。** アプリが別のアプリからの要求に応答できるようにします。 | アプリで**インテント フィルター**に**インテント処理動作**を登録し、別のアプリからの暗黙的インテントに対応します。 | **アプリの拡張機能**をパッケージ化すると、データを他のアプリと共有できます。 アプリで**カスタム URL スキーム**を登録するには、Info.plist で **CFBundleURLTypes** キーを使います。 | アプリを **URI スキーム名**の既定のハンドラーとして登録するには、パッケージ マニフェストに**[プロトコル](https://msdn.microsoft.com/library/windows/apps/windows.applicationmodel.activation.activationkind.aspx#Protocol)**を登録して **[Application.OnActivated](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.application.onactivated.aspx)** イベント ハンドラーを更新し、必要に応じて結果を返すようにします。 同様に、アプリを特定のファイルの種類の既定のハンドラーとして登録するには、パッケージ マニフェストに宣言を追加して **[Application.OnFileActivated](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.application.onfileactivated.aspx)** イベントを処理します。<br/><br/>共有コントラクトの要求を処理するには、マニフェストで共有ターゲットとしてアプリを登録し、**[Application.OnShareTargetActivated](https://msdn.microsoft.com/library/windows/apps/xaml/windows.ui.xaml.application.onsharetargetactivated.aspx)** イベントを処理します。<br/><br/>[結果を取得するためのアプリの起動](https://msdn.microsoft.com/library/windows/apps/mt269386.aspx)<br/><br/>[ファイルのアクティブ化の処理](https://msdn.microsoft.com/library/windows/apps/mt269385.aspx)<br/><br/>[データの受信](https://msdn.microsoft.com/library/windows/apps/xaml/mt243292.aspx) |
|  **コピーと貼り付け。** アプリ間でテキストやその他のコンテンツをコピーしたり貼り付けしたりします。 | **クリップボード フレームワーク**を使って、**ClipboardManager** と **ClipData** の各クラスでコピーと貼り付けを実装できます。 | **UIPasteboard**、**UIMenuController**、**UIResponderStandardEditActions** を使って、コピーとペーストを実装できます。 | 多くの既定の XAML コントロールは既にコピーと貼り付けをサポートしています。 自分でコピーと貼り付けを実装するには、**[Windows.ApplicationModel.DataTransfer](https://msdn.microsoft.com/library/windows/apps/br205967)** の **[DataPackage](https://msdn.microsoft.com/library/windows/apps/windows.applicationmodel.datatransfer.datapackage.aspx)** と **[Clipboard](https://msdn.microsoft.com/library/windows/apps/xaml/windows.applicationmodel.datatransfer.clipboard.aspx)** の各クラスを使います。<br/><br/>[コピーと貼り付け](https://msdn.microsoft.com/library/windows/apps/xaml/mt243291.aspx) |
|  **ドラッグ アンド ドロップ。** アプリ間でコンテンツをドラッグ アンド ドロップします。 | 1 つのアプリケーションにドラッグ アンド ドロップを実装するには、**Android ドラッグ/ドロップ フレームワーク**を使います。 | iOS では高度なドラッグ アンド ドロップ API は提供されていません。 | アプリにドラッグ アンド ドロップを実装すると、アプリとアプリ、デスクトップとアプリ、アプリとデスクトップのドラッグ アンド ドロップ機能を有効にできます。 UIElement クラスにドラッグ アンド ドロップのサポートを実装するには、**[AllowDrop](https://msdn.microsoft.com/library/windows/apps/xaml/windows.ui.xaml.uielement.allowdrop.aspx)** と **[CanDrag](https://msdn.microsoft.com/library/windows/apps/xaml/windows.ui.xaml.uielement.candrag.aspx)** の各プロパティ、**[DragOver](https://msdn.microsoft.com/library/windows/apps/xaml/windows.ui.xaml.uielement.dragover.aspx)** と **[Drop](https://msdn.microsoft.com/library/windows/apps/xaml/windows.ui.xaml.uielement.drop.aspx)** の各イベントを使います。<br/><br/>[ドラッグ アンド ドロップ](https://msdn.microsoft.com/library/windows/apps/xaml/mt227651.aspx) |

## ソフトウェアの設計

|  **一般的な概念** | **Android** | **iOS** | **Windows 10** |
|  ------ | ------ | ------ | ------ |
|  **ソフトウェアの設計パターン。** プラットフォーム向けの推奨パターンまたはよく使われるパターン。 | 正式なパターンは、推奨されていないか、Android の開発用に提供されていません。ただし、ベータ版のデータ バインディング フレームワークでは、**モデル - ビュー - ビューモデル (MVVM)** パターンを現在よりも利用できるようになる可能性があります。 多くのサード パーティの記事やフレームワークでは、**モデル ビュー プレゼンター (MVP)** と **MVVM** を使った方法を推奨しています。 | **モデル - ビュー - コントローラー (MVC)** は iOS で使用される一般的なパターンであり、プラットフォームに統合されています。 | UWP 用のアプリ作成時、特定のパターンに制限されません。<br/><br/>組み込みの [データ バインディング](https://msdn.microsoft.com/library/windows/apps/mt210947.aspx) パターンを使って、データの問題と UI の問題を明確に切り離すことができ、後でプロパティ値を更新する UI イベント ハンドラーをコード内に記述することを回避できます。<br/><br/>データ バインディングを拡張して**モデル - ビュー - ビューモデル (MVVM)** パターンに従うことができます。そのためには、[MVVM Light Toolkit](https://mvvmlight.codeplex.com/) などのサード パーティの MVVM ライブラリを使うか、独自に展開してロジックをコードビハインドから排除します。<br/><br/>[MVVM パターン](https://msdn.microsoft.com/library/hh848246.aspx)<br/><br/>[Template 10 Visual Studio プロジェクト テンプレート](https://github.com/Windows-XAML/Template10/wiki) |


<!--HONumber=Mar16_HO1-->


