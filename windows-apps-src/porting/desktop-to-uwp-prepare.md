---
author: awkoren
Description: "この記事では、Desktop to UWP Bridge を使用してアプリを変換する前に理解しておく必要のあることについて説明します。 アプリの変換プロセス準備に多くの作業は必要ありません。"
Search.Product: eADQiWindows 10XVcnh
title: "Desktop to UWP Bridge 用にアプリを準備する"
translationtype: Human Translation
ms.sourcegitcommit: f7a8b8d586983f42fe108cd8935ef084eb108e35
ms.openlocfilehash: 81a2485d5be22dd392c21aaff281c1c9263883a9

---

# <a name="prepare-an-app-for-conversion-with-the-desktop-bridge"></a>Desktop Bridge での変換用にアプリを準備する

この記事では、Desktop to UWP Bridge を使用してアプリを変換する前に理解しておく必要のあることについて説明します。 変換プロセス用にアプリを準備するためには多くの作業を行う必要はありませんが、以下の項目のいずれかがアプリケーションに当てはまる場合には、変換の前に対処する必要があります。 ライセンスと自動更新は Windows ストアで処理されるため、これらの機能はコードベースから削除できます。

+ __アプリでバージョン 4.6.1 よりも前のバージョンの .NET を使用している__。 .NET 4.6.1 のみがサポートされています。 変換する前にアプリのターゲットを .NET 4.6.1 に変更する必要があります。 

+ __常に管理者特権のセキュリティ権限でアプリを実行する__。 アプリは、対話ユーザーとして実行中にも機能する必要があります。 Windows ストアからアプリをインストールするユーザーはシステム管理者ではない可能性があります。そのため、アプリは、標準ユーザーでは正しく動作しない、管理者だけが実行できる方法で実行する必要があります。

+ __アプリにカーネル モード ドライバーや Windows サービスが必要__。 ブリッジはアプリには適していますが、システム アカウントで実行する必要があるカーネル モード ドライバーや Windows サービスはサポートしていません。 Windows サービスの代わりに、[バックグラウンド タスク](https://msdn.microsoft.com/windows/uwp/launch-resume/create-and-register-a-background-task)を使います。

+ __アプリのモジュールが AppX パッケージに含まれていないプロセスに読み込まれるインプロセスである__。 これは許可されていません。つまり、[シェルの拡張機能](https://msdn.microsoft.com/library/windows/desktop/dd758089.aspx)などのインプロセスの拡張機能はサポートされていません。 ただし、同じパッケージに 2 つのアプリが含まれている場合に、そのアプリ間でプロセス間通信することはできます。

+ __アプリが [SetDllDirectory](https://msdn.microsoft.com/library/windows/desktop/ms686203) または [AddDllDirectory](https://msdn.microsoft.com/library/windows/desktop/hh310513)__ を呼び出す。 現在、これらの関数は変換されたアプリでサポートされていません。 今後のリリースでサポートが追加される予定です。 この問題を回避するには、これらの関数を使うために配置している .dll をすべてパッケージのルートにコピーします。 

+ __アプリでカスタム アプリケーション ユーザー モデル ID (AUMID) を使う__。 プロセスから [SetCurrentProcessExplicitAppUserModelID](https://msdn.microsoft.com/library/windows/desktop/dd378422.aspx) を呼び出して独自の AUMID を設定する場合、アプリ モデル環境/AppX パッケージでその目的で生成された AUMID しか使えません。 カスタムの AUMID を定義することはできません。

+ __アプリが HKEY_LOCAL_MACHINE (HKLM) レジストリ ハイブを変更する__。 アプリから HKLM キーを作成しようとしたり、変更のために開こうとしたりすると、アクセス拒否エラーが発生します。 アプリには、レジストリを仮想化した独自のプライベート ビューがあるため、ユーザーやマシン全体のレジストリ ハイブ (HKLM はこれに相当) の概念は適用されないことに注意してください。 HKLM を使って実現していたことを、HKEY_CURRENT_USER (HKCU) に書き込むなど別の方法で実現する必要があります。

+ __アプリで、別のアプリを起動する手段として ddeexec レジストリ サブキーを使っている__。 代わりに、[アプリ パッケージ マニフェスト](https://msdn.microsoft.com/library/windows/apps/br211474.aspx)のさまざまなアクティブ化可能* な拡張機能で構成する DelegateExecute verb ハンドラーの 1 つを使います。

+ __アプリが、別のアプリとデータを共有するために AppData フォルダーに書き込みを行う__。 変換後、AppData はローカル アプリ データ ストアにリダイレクトされます。このストアは、各 UWP アプリのプライベート ストアです。 プロセス間データ共有に別の方法を使います。 詳しくは、「[設定と他のアプリ データを保存して取得する](https://msdn.microsoft.com/windows/uwp/app-settings/store-and-retrieve-app-data)」をご覧ください。

+ __アプリが、アプリのインストール ディレクトリに書き込みを行う__。 たとえば、exe と同じディレクトリに置いたログ ファイルにアプリが書き込む場合などです。 この書き込みは、サポートされていないため、ローカル アプリ データ ストアなどの別の場所にする必要があります。

+ __アプリのインストールでユーザーの対話式操作を求める__。 アプリ インストーラーはサイレント実行でき、クリーンな状態の OS イメージには既定では存在しないすべての前提条件をインストールする必要があります。

+ __アプリで現在の作業ディレクトリを使う__。 変換済みのアプリでは、実行時に、デスクトップで以前に指定していたのと同じ作業ディレクトリ (.LNK ショートカット) を取得しません。 アプリを正しく動作させるために現在のディレクトリを取得することが重要な場合は、実行時に CWD を変更する必要があります。

+ __アプリで UIAccess が必要__。 アプリケーションが UAC マニフェストの `requestedExecutionLevel` 要素で `UIAccess=true` を指定している場合の UWP への変換は現在サポートされていません。 詳しくは、「[UI オートメーション セキュリティの概要](https://msdn.microsoft.com/library/ms742884.aspx)」をご覧ください。

+ __他のプロセスで使用できるように COM オブジェクトや GAC アセンブリをアプリで公開している__。 現在のリリースでは、AppX パッケージ外部の実行可能ファイルから生成されたプロセスで使用できるように、アプリが COM オブジェクトや GAC アセンブリを公開することはできません。 パッケージ内のプロセスは、通常どおり、COM オブジェクトや GAC アセンブリを登録して使用できますが、外部からは認識されません。 つまり、OLE などの相互運用機能のシナリオは、外部プロセスによって呼び出された場合、機能しません。 

+ __サポートされていない方法でアプリが C ランタイム ライブラリ (CRT) にリンクされている__。 Microsoft C/C++ ランタイム ライブラリは、Microsoft Windows オペレーティング システムのプログラミングのルーチンを提供します。 これらのルーチンは、C および C++ 言語では提供されない、多くの一般的なプログラミング タスクを自動化します。 アプリで C/C++ ランタイム ライブラリを使用している場合、サポートされている方法でリンクされていることを確認する必要があります。 
    
    Visual Studio 2015 は、現在のバージョンの CRT に対して、コードで共通の DLL ファイルを使用できるようにするダイナミック リンクと、コードに直接ライブラリをリンクするスタティック リンクの両方をサポートしています。 可能であれば、アプリで VS 2015 へのダイナミック リンクを使用することをお勧めします。 

    以前のバージョンの Visual Studio でのサポートは異なります。 詳しくは、次の表をご覧ください。 

    <table>
    <th>Visual Studio のバージョン</td><th>ダイナミック リンク</th><th>スタティック リンク</th></th>
    <tr><td>2005 (VC 8)</td><td>サポートされない</td><td>サポートされる</td>
    <tr><td>2008 (VC 9)</td><td>サポートされない</td><td>サポートされる</td>
    <tr><td>2010 (VC 10)</td><td>サポートされる</td><td>サポートされる</td>
    <tr><td>2012 (VC 11)</td><td>サポートされる</td><td>サポートされない</td>
    <tr><td>2013 (VC 12)</td><td>サポートされる</td><td>サポートされない</td>
    <tr><td>2015 (VC 14)</td><td>サポートされる</td><td>サポートされる</td>
    </table>
    
    注: いずれの場合も、最新の公開されている CRT にリンクする必要があります。

+ __アプリが Windows サイドバイサイド フォルダーからアセンブリをインストールする/読み込む__。 たとえば、アプリが C ランタイム ライブラリ VC8 または VC9 を使用しており、Windows サイドバイサイド フォルダーから動的にリンクしている、つまり、コードが共有フォルダーから共通の DLL ファイルを使用しているとします。 これはサポートされていません。 再頒布可能なライブラリ ファイルをコードに直接リンクして、静的にリンクする必要があります。

+ __アプリが、System32/SysWOW64 フォルダーの依存関係を使っている__。 DLL が機能するためには、AppX パッケージの仮想ファイル システム部分にそれらの DLL を含める必要があります。 これにより、アプリは DLL が **System32**/**SysWOW64** フォルダーにインストールされている場合と同じように動作します。 パッケージのルートで **VFS** という名前のフォルダーを作成します。 そのフォルダー内に、**SystemX64** フォルダーと **SystemX86**フォルダーを作成します。 **SystemX86** フォルダーに DLL の 32 ビット バージョンを格納し、**SystemX64** フォルダーに 64 ビット バージョンを格納します。

+ __アプリが Dev11 VCLibs フレームワーク パッケージを使っている__。 VCLibs 11 ライブラリは、AppX パッケージで依存関係として定義されている場合、Windows ストアから直接インストールできます。 これを行うには、`<Dependencies>` ノードの下に、以下を追加して変更する必要があります。  
`<PackageDependency Name="Microsoft.VCLibs.110.00.UWPDesktop" MinVersion="11.0.24217.0" Publisher="CN=Microsoft Corporation, O=Microsoft Corporation, L=Redmond, S=Washington, C=US" />`  
Windows ストアからインストールするとき、アプリをインストールする前に VCLibs 11 フレームワークの適切なバージョン (x86 または x64) がインストールされます。  
アプリがサイドローディングによってインストールされる場合は、依存関係がインストールされません。 コンピューター上に依存関係を手動でインストールするには、[VC 11.0 Desktop Bridge 用フレームワーク パッケージ](https://www.microsoft.com/download/details.aspx?id=53340&WT.mc_id=DX_MVP4025064)をダウンロードしてインストールする必要があります。 これらのシナリオについて詳しくは、「[Using Visual C++ Runtime in Centennial project (Centennial プロジェクトで Visual C++ ラインタイムを使用する)](https://blogs.msdn.microsoft.com/vcblog/2016/07/07/using-visual-c-runtime-in-centennial-project/)」をご覧ください。


<!--HONumber=Dec16_HO1-->


