---
Description: この記事では、お客様のデスクトップ アプリケーションをパッケージ化する前に知っておくべきことを示します。 アプリのパッケージ化プロセスの準備に多くの作業は必要ありません。
Search.Product: eADQiWindows 10XVcnh
title: デスクトップ アプリケーション (デスクトップ ブリッジ) をパッケージ化するための準備します。
ms.date: 05/18/20188
ms.topic: article
keywords: windows 10, uwp
ms.assetid: 71a57ca2-ca00-471d-8ad9-52f285f3022e
ms.localizationpriority: medium
ms.openlocfilehash: 49238ba1b72cf3daf46fb076432a478e9f381bc6
ms.sourcegitcommit: b034650b684a767274d5d88746faeea373c8e34f
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/06/2019
ms.locfileid: "57600897"
---
# <a name="prepare-to-package-a-desktop-application"></a>デスクトップ アプリケーションをパッケージ化するための準備します。

この記事では、デスクトップ アプリをパッケージ化する前に理解しておく必要のあることについて説明します。 パッケージ化プロセスでは、アプリケーションを準備する処理に苦労する必要がありますされませんが、次の項目のいずれかは、アプリケーションに適用する場合にパッケージ化する前に、対処する必要があります。 ライセンスと自動更新は Microsoft Store で処理されるため、これらのタスクに関連した機能はコードベースから削除できます。

>[!IMPORTANT]
>(それ以外の場合は、デスクトップ ブリッジと呼ばれます) デスクトップ アプリケーションの Windows アプリ パッケージを作成する機能は Windows 10 バージョン 1607 で導入され、Windows 10 Anniversary Update (10.0; を対象とするプロジェクトでのみ使用できます。ビルド 14393) または Visual Studio の今後のリリース。

+ __アプリケーションには、.NET 4.6.2 より前のバージョンが必要な__します。 .NET 4.6.2 でアプリケーションを実行することを確認する必要があります。 4.6.2 より前のバージョンを要求したり、再配布したりすることはできません。 これは、Windows 10 Anniversary Update で出荷された .NET のバージョンです。 このバージョンに、アプリケーションが動作を確認するには、Windows 10 の今後の更新プログラムと互換性があるアプリケーションが引き続き保証されます。  アプリケーションが .NET Framework 4.0 またはそれ以降を対象と場合は、.NET 4.6.2 で実行することが想定されますが、引き続きテストする必要があります。

+ __常にアプリケーションを管理者特権でのセキュリティ特権を持つ実行__します。 アプリケーションは、対話型ユーザーとして実行中に操作する必要があります。 Microsoft Store からアプリをインストールするユーザーには、システム管理者、そのため、アプリケーションが管理者特権では、標準ユーザーが正しく実行されないことを意味の実行を必要とする可能性がありますできません。 機能の一部で昇格を必要とするアプリは、Microsoft Store では受け入れられません。

+ __アプリケーションは、カーネル モード ドライバーまたは Windows サービスが必要です。__ します。 ブリッジはアプリには適していますが、システム アカウントで実行する必要があるカーネル モード ドライバーや Windows サービスはサポートしていません。 Windows サービスの代わりに、[バックグラウンド タスク](https://msdn.microsoft.com/windows/uwp/launch-resume/create-and-register-a-background-task)を使います。

+ __アプリのモジュールが、Windows アプリ パッケージに含まれていないプロセスに読み込まれるインプロセスである__。 これは許可されていません。つまり、[シェルの拡張機能](https://msdn.microsoft.com/library/windows/desktop/dd758089.aspx)などのインプロセスの拡張機能はサポートされていません。 ただし、同じパッケージに 2 つのアプリが含まれている場合に、そのアプリ間でプロセス間通信することはできます。

+ __アプリケーションで使用するカスタム アプリケーション ユーザー モデル ID (AUMID)__ します。 プロセスを呼び出す場合[SetCurrentProcessExplicitAppUserModelID](https://msdn.microsoft.com/library/windows/desktop/dd378422.aspx)を独自の AUMID を設定するには、その可能性がありますのみを使用して AUMID アプリケーション モデル環境/Windows アプリ パッケージを生成します。 カスタムの AUMID を定義することはできません。

+ __アプリケーションは、HKEY_LOCAL_MACHINE (HKLM) レジストリ ハイブを変更します。__ します。 しようとすると、アプリケーションで、HKLM キーを作成または変更については、いずれかを開くには、アクセス拒否エラーが発生します。 アプリケーションの独自のプライベート仮想化されたビュー、レジストリのユーザーとコンピューター全体のレジストリ ハイブ (これは、HKLM は) の概念は適用されませんので注意してください。 HKLM を使って実現していたことを、HKEY_CURRENT_USER (HKCU) に書き込むなど別の方法で実現する必要があります。

+ __アプリケーションが別のアプリを起動するための手段として ddeexec レジストリ サブキーを使用して__します。 代わりに、[アプリ パッケージ マニフェスト](https://msdn.microsoft.com/library/windows/apps/br211474.aspx)のさまざまなアクティブ化可能* な拡張機能で構成する DelegateExecute verb ハンドラーの 1 つを使います。

+ __AppData フォルダーまたは別のアプリとデータを共有する目的でレジストリにアプリケーションが書き込む__します。 変換後、AppData はローカル アプリ データ ストアにリダイレクトされます。このストアは、各 UWP アプリのプライベート ストアです。

  アプリケーションが、HKEY_LOCAL_MACHINE レジストリ ハイブに書き込むすべてのエントリは分離のバイナリ ファイルにリダイレクトされ、アプリケーションが、HKEY_CURRENT_USER レジストリ ハイブに書き込むすべてのエントリは、プライベート、ユーザーごとに、アプリごとの場所に配置されます。 ファイルとレジストリのリダイレクトの詳細については、「[デスクトップ ブリッジの内側](desktop-to-uwp-behind-the-scenes.md)」をご覧ください。  

  プロセス間データ共有に別の方法を使います。 詳しくは、「[設定と他のアプリ データを保存して取得する](https://msdn.microsoft.com/windows/uwp/app-settings/store-and-retrieve-app-data)」をご覧ください。

+ __アプリケーションが、アプリのインストール ディレクトリに書き込む__します。 たとえば、アプリケーションは、exe ファイルと同じディレクトリに格納されているログ ファイルに書き込みます。 この書き込みは、サポートされていないため、ローカル アプリ データ ストアなどの別の場所にする必要があります。

+ __アプリケーションのインストールがユーザーの介入を必要と__します。 アプリケーションのインストーラーは自動的に実行できる必要があり、クリーンな OS イメージでは既定ではない前提条件をすべてをインストールする必要があります。

+ __アプリケーションは、現在の作業ディレクトリを使用して__します。 実行時にパッケージ化されたデスクトップ アプリケーションは、デスクトップで以前に指定した同じ作業ディレクトリを取得されません。LNK ショートカットです。 適切なディレクトリが正常に動作するアプリケーションの重要な場合は、実行時に、CWD を変更する必要があります。

+ __アプリケーションで必要な UIAccess__します。 アプリケーションが UAC マニフェストの `requestedExecutionLevel` 要素で `UIAccess=true` を指定している場合の UWP への変換は現在サポートされていません。 詳しくは、「[UI オートメーション セキュリティの概要](https://msdn.microsoft.com/library/ms742884.aspx)」をご覧ください。

+ __アプリケーションに公開する COM オブジェクト__します。 パッケージ内のプロセスと拡張機能は、インプロセスとアウト プロセス (OOP) の両方で、COM サーバーおよび OLE サーバーを登録して使用できます。  Creators Update では、Packaged COM のサポートが追加されています。これにより、パッケージ外部で表示されるようになった OOP COM サーバーおよび OLE サーバーを登録できるようになります。  [COM サーバーおよび OLE ドキュメントのデスクトップ ブリッジ用サポート](https://blogs.windows.com/buildingapps/2017/04/13/com-server-ole-document-support-desktop-bridge/#bjPyETFgtpZBGrS1.97)に関するブログをご覧ください。

   Packaged COM のサポートは、既存の COM API に使用できますが、Packaged COM の場所はプライベートであるため、レジストリの読み取りに直接依存するアプリケーションの拡張機能には使用できません。

+ __アプリケーションでは、他のプロセスで使用するアセンブリを GAC が公開する__します。 現在のリリースで、アプリケーションは、Windows アプリ パッケージを実行可能ファイルが外部から発信されるプロセスで使用するアセンブリを GAC を公開できません。 パッケージ内のプロセスは、通常どおり、GAC アセンブリを登録して使用できますが、外部からは認識されません。 つまり、OLE などの相互運用機能のシナリオは、外部プロセスによって呼び出された場合、機能しません。

+ __アプリケーションではサポートされていない方法で C ランタイム ライブラリ (CRT) がリンク__します。 Microsoft C/C++ ランタイム ライブラリは、Microsoft Windows オペレーティング システムのプログラミングのルーチンを提供します。 これらのルーチンは、C および C++ 言語では提供されない、多くの一般的なプログラミング タスクを自動化します。 場合は、アプリケーションは、C/C++ ランタイム ライブラリを利用して、サポートされている方法でリンクされていることを確認する必要があります。

    Visual Studio 2017 は、現在のバージョンの CRT に対して、コードで共通の DLL ファイルを使用できるようにするダイナミック リンクと、コードに直接ライブラリをリンクするスタティック リンクの両方をサポートしています。 可能であれば、アプリケーションの使用を動的に VS 2017 とのリンクをお勧めします。

    以前のバージョンの Visual Studio でのサポートは異なります。 詳しくは、次の表をご覧ください。

    <table>
    <th>Visual Studio のバージョン</td><th>ダイナミック リンク</th><th>スタティック リンク</th></th>
    <tr><td>2005 (VC 8)</td><td>サポートされない</td><td>サポート対象</td>
    <tr><td>2008 (VC 9)</td><td>サポートされない</td><td>サポート対象</td>
    <tr><td>2010 (VC 10)</td><td>サポート対象</td><td>サポート対象</td>
    <tr><td>2012 (VC 11)</td><td>サポート対象</td><td>サポートされない</td>
    <tr><td>2013 (VC 12)</td><td>サポート対象</td><td>サポートされない</td>
    <tr><td>2015 および 2017 (VC 14)</td><td>サポート対象</td><td>サポート対象</td>
    </table>

    注:すべてのケースで最新にリンクする必要があります CRT を公開します。

+ __アプリケーションがインストールされ、Windows のサイド バイ サイドでフォルダーからアセンブリを読み込みます__します。 たとえば、アプリケーションでは、VC8 または VC9 の C ランタイム ライブラリを使用してが動的にリンクすることつまり共有フォルダーから、コードが共通の DLL ファイルを使用して、Windows のサイド バイ サイドでフォルダーから。 これはサポートされていません。 再頒布可能なライブラリ ファイルをコードに直接リンクして、静的にリンクする必要があります。

+ __アプリケーション/SysWOW64 System32 フォルダーで依存関係を使用して__します。 DLL が機能するためには、Windows アプリ パッケージの仮想ファイル システム部分にそれらの DLL を含める必要があります。 これにより、アプリケーションで、Dll がインストールされたかのように動作する、 **System32**/**SysWOW64**フォルダー。 パッケージのルートで **VFS** という名前のフォルダーを作成します。 そのフォルダー内に、**SystemX64** フォルダーと **SystemX86**フォルダーを作成します。 **SystemX86** フォルダーに DLL の 32 ビット バージョンを格納し、**SystemX64** フォルダーに 64 ビット バージョンを格納します。

+ __アプリが VCLibs フレームワーク パッケージを使っている__。 VCLibs 11 ライブラリは、Windows アプリ パッケージで依存関係として定義されている場合、Microsoft Store から直接インストールできます。 たとえば、アプリケーションでは、Dev11 VCLibs パッケージを使用する場合は、アプリケーション パッケージ マニフェストに、次の変更をください。、`<Dependencies>`ノードを追加します。  
`<PackageDependency Name="Microsoft.VCLibs.110.00.UWPDesktop" MinVersion="11.0.24217.0" Publisher="CN=Microsoft Corporation, O=Microsoft Corporation, L=Redmond, S=Washington, C=US" />`  
Microsoft Store からインストールするとき、アプリをインストールする前に VCLibs フレームワークの適切なバージョン (x86 または x64) がインストールされます。  
依存関係がインストールされず、サイドローディングによってアプリケーションがインストールされている場合。 コンピューター上に依存関係を手動でインストールするには、デスクトップ ブリッジ用の適切な VCLibs フレームワーク パッケージをダウンロードしてインストールする必要があります。 これらのシナリオについて詳しくは、[Centennial プロジェクトで Visual C++ ラインタイムを使用する方法に関するページ](https://blogs.msdn.microsoft.com/vcblog/2016/07/07/using-visual-c-runtime-in-centennial-project/)をご覧ください。

  **フレームワーク パッケージ**:

  * [デスクトップ ブリッジの VC 14.0 フレームワーク パッケージ](https://www.microsoft.com/download/details.aspx?id=53175)
  * [デスクトップ ブリッジの VC 12.0 framework パッケージ](https://www.microsoft.com/download/details.aspx?id=53176)
  * [デスクトップ ブリッジの VC 11.0 framework パッケージ](https://www.microsoft.com/download/details.aspx?id=53340)


+ __アプリケーションのカスタム ジャンプ リストに含まれる__します。 ジャンプ リストを使用する場合は、いくつかの問題と注意事項があります。

    - __アプリのアーキテクチャでは、OS は一致しません。__  ジャンプ リスト現在が正しく機能しません、アプリケーションと OS アーキテクチャが一致しない場合 (x86、x64 で実行されているアプリケーション Windows)。 この時点ではありません回避策以外のアプリケーションに対応するアーキテクチャを再コンパイルします。

    - __アプリケーションは、ジャンプ リストのエントリと呼び出しを作成します。 [ICustomDestinationList::SetAppID](https://msdn.microsoft.com/library/windows/desktop/dd378403(v=vs.85).aspx)または[SetCurrentProcessExplicitAppUserModelID](https://msdn.microsoft.com/library/windows/desktop/dd378422(v=vs.85).aspx)__ します。 プログラムによって AppID をコードに設定しないでください。 そうすると、ジャンプ リストの項目が表示されません。 アプリケーションでは、カスタム Id を必要とする場合は、マニフェスト ファイルを使用して指定します。 参照してください[デスクトップ アプリケーションを手動でパッケージ化](desktop-to-uwp-manual-conversion.md)手順についてはします。 アプリケーションの AppID は *YOUR_PRAID_HERE* セクションに指定されます。

    - __アプリケーションは、パッケージの実行可能ファイルを参照するジャンプ リスト シェルのリンクを追加します。__ します。 ジャンプ リストから直接、パッケージ内の実行可能ファイルを起動することはできません (アプリ自体の .exe の絶対パスを使用する場合は除く)。 代わりに、(これにより、パス上のように、キーワードを使用して開始する場合は、パッケージ化されたデスクトップ アプリケーション) アプリの実行のエイリアスを登録し、代わりにエイリアスをリンク先のパスを設定します。 AppExecutionAlias 拡張機能の使用方法の詳細については、次を参照してください。[と Windows 10 デスクトップ アプリケーションを統合](desktop-to-uwp-extensions.md)します。 元の .exe に一致するジャンプ リストのリンク アセットが必要な場合は、他のカスタム項目と同様に、[**SetIconLocation**](https://msdn.microsoft.com/library/windows/desktop/bb761047(v=vs.85).aspx) を使用してアイコンなどのアセットを設定し、PKEY_Title を使用して名前を表示します。

    - __アプリケーションは、絶対パスでアプリのパッケージ内の資産を参照するジャンプ リストのエントリを追加します。__ します。 アプリケーションのインストール パスは、そのパッケージが更新される、資産 (アイコン、ドキュメント、実行可能ファイルなど) の場所を変更するときに変更できます。 ジャンプ リストのエントリで絶対パスは、このような資産を参照するかどうかは、アプリケーションがリストを更新ジャンプ定期的に (アプリケーションの起動など) のパスが正しく解決を確認します。 または、UWP [**Windows.UI.StartScreen.JumpList**](https://msdn.microsoft.com/library/windows/apps/windows.ui.startscreen.jumplist.aspx) API を使用します。この API では、package-relative ms-resource URI スキーマ (これは言語、DPI、ハイ コントラストにも対応します) を使用して、文字列アセットと画像アセットを参照できます。

+ __アプリケーションの開始タスクを実行するためのユーティリティ__します。 PowerShell や Cmd.exe など、コマンド ユーティリティの起動は避けてください。 実際には、ユーザーは、Windows 10 S を実行しているシステムにアプリケーションをインストールする場合、アプリケーションできませんまったくを起動します。 Microsoft Store に送信されたすべてのアプリを Windows 10 s. と互換性があるため、アプリケーション Microsoft Store への送信からをブロックこれでした。

ユーティリティの起動は、オペレーティング システムからの情報の取得、レジストリへのアクセス、システム機能へのアクセスなどを行うための手段として便利であることが少なくありません。 ただし、このような作業を実行するには、代わりに UWP API を使用することができます。 これらの Api を実行する独立した実行可能ファイルが必要はありませんが、さらに、維持、アプリケーション パッケージの外部に到達できないために、パフォーマンスが向上です。 アプリのデザインが分離、信頼、およびパッケージ化したことと、アプリケーションの Windows 10 s. を実行しているシステムで期待どおりに動作するアプリケーションに付属しているセキュリティと一致

+ __アプリケーションは、アドイン、プラグイン、または拡張機能をホスト__します。   多くの場合、COM スタイルの拡張機能は、引き続き動作します。ただし、拡張機能がパッケージ化されておらず、完全信頼としてインストールされている場合に限られます。 これらのインストーラーが、完全に信頼された機能を使用してレジストリを変更し、ホスト アプリケーションがそれらを参照する任意の場所は、拡張機能のファイルを配置するためです。

   ただし、これらの拡張機能は、パッケージ化し、Windows アプリ パッケージとしてインストールしの場合は、(ホスト アプリケーションと拡張機能) は、各パッケージは互いから分離されますので、機能しません。 詳細を確認する方法アプリケーションから分離されたシステムを参照してください[デスクトップ ブリッジの裏側](desktop-to-uwp-behind-the-scenes.md)します。

 Windows 10 S を実行するシステムにユーザーがインストールするすべてのアプリケーションおよび拡張機能は、Windows アプリ パッケージとしてインストールされる必要があります。 したがって、拡張機能をパッケージ化する、またはパッケージ化、共同作成者をお勧めする、ホスト アプリケーションのパッケージとすべての拡張機能パッケージ間の通信を促進する方法を検討します。 1 つの方法として、[アプリ サービス](../launch-resume/app-services.md)を使用することもできます。

+ __アプリケーションのコードを生成する__します。 アプリケーションは、メモリ内に使用するコードを生成できますが、Windows アプリ認定プロセスは、アプリの提出する前にそのコードを検証できませんので、ディスクに書き込みが生成されたコードを回避します。 また、アプリ コードをディスクに書き込むことが適切に実行できません S. の Windows 10 を実行しているシステムMicrosoft Store に送信されたすべてのアプリを Windows 10 s. と互換性があるため、アプリケーション Microsoft Store への送信からをブロックこれでした。

>[!IMPORTANT]
> Windows アプリ パッケージを作成した後は、Windows 10 s. を実行するシステムで正しく動作するために、アプリケーションをテストしてください。Microsoft Store に送信されたすべてのアプリと互換性がある互換性のない Windows 10 s. アプリをストアに承諾されません。 「[Windows アプリの Windows 10 S 対応をテストする](desktop-to-uwp-test-windows-s.md)」をご覧ください。

## <a name="next-steps"></a>次のステップ

**質問の回答を検索**

ご質問がある場合は、 Stack Overflow でお問い合わせください。 Microsoft のチームでは、これらの[タグ](https://stackoverflow.com/questions/tagged/project-centennial+or+desktop-bridge)をチェックしています。 [こちら](https://social.msdn.microsoft.com/Forums/en-US/home?filter=alltypes&sort=relevancedesc&searchTerm=%5BDesktop%20Converter%5D)から質問することもできます。

**ご意見や機能を提案します。**

[UserVoice](https://wpdev.uservoice.com/forums/110705-universal-windows-platform/category/161895-desktop-bridge-centennial) のページをご覧ください。

**デスクトップ アプリ用の Windows アプリ パッケージを作成します。**

「[Windows アプリ パッケージを作成する](desktop-to-uwp-root.md#convert)」をご覧ください。
